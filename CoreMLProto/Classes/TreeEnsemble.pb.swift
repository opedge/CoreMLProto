// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: TreeEnsemble.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

// Copyright (c) 2017, Apple Inc. All rights reserved.
//
// Use of this source code is governed by a BSD-3-clause license that can be
// found in LICENSE.txt or at https://opensource.org/licenses/BSD-3-Clause

//*
// Each tree is a collection of nodes,
// each of which is identified by a unique identifier.
//
// Each node is either a branch or a leaf node.
// A branch node evaluates a value according to a behavior;
// if true, the node identified by ``true_child_node_id`` is evaluated next,
// if false, the node identified by ``false_child_node_id`` is evaluated next.
// A leaf node adds the evaluation value to the base prediction value
// to get the final prediction.
//
// A tree must have exactly one root node,
// which has no parent node.
// A tree must not terminate on a branch node.
// All leaf nodes must be accessible
// by evaluating one or more branch nodes in sequence,
// starting from the root node.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///*
/// A tree ensemble post-evaluation transform.
public enum CoreML_Specification_TreeEnsemblePostEvaluationTransform: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case noTransform // = 0
  case classificationSoftMax // = 1
  case regressionLogistic // = 2
  case classificationSoftMaxWithZeroClassReference // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .noTransform
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .noTransform
    case 1: self = .classificationSoftMax
    case 2: self = .regressionLogistic
    case 3: self = .classificationSoftMaxWithZeroClassReference
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .noTransform: return 0
    case .classificationSoftMax: return 1
    case .regressionLogistic: return 2
    case .classificationSoftMaxWithZeroClassReference: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

///*
/// Tree ensemble parameters.
public struct CoreML_Specification_TreeEnsembleParameters: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".TreeEnsembleParameters"

  public var nodes: [CoreML_Specification_TreeEnsembleParameters.TreeNode] = []

  ///*
  /// The number of prediction dimensions or classes in the model.
  ///
  /// All instances of ``evaluationIndex`` in a leaf node
  /// must be less than this value,
  /// and the number of values in the ``basePredictionValue`` field
  /// must be equal to this value.
  ///
  /// For regression,
  /// this is the dimension of the prediction.
  /// For classification,
  /// this is the number of classes.
  public var numPredictionDimensions: UInt64 = 0

  ///*
  /// The base prediction value.
  ///
  /// The number of values in this must match
  /// the default values of the tree model.
  public var basePredictionValue: [Double] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct TreeNode: SwiftProtobuf.Message {
    public static let protoMessageName: String = CoreML_Specification_TreeEnsembleParameters.protoMessageName + ".TreeNode"

    public var treeID: UInt64 = 0

    public var nodeID: UInt64 = 0

    ///*
    /// The branch mode parameters.
    ///
    /// If branch is false,
    /// then the parameters in this section must be filled in
    /// to determine how the branching functions.
    public var nodeBehavior: CoreML_Specification_TreeEnsembleParameters.TreeNode.TreeNodeBehavior = .branchOnValueLessThanEqual

    ///*
    /// If the node behavior mode is a branch mode,
    /// then these values must be filled in.
    public var branchFeatureIndex: UInt64 = 0

    public var branchFeatureValue: Double = 0

    public var trueChildNodeID: UInt64 = 0

    public var falseChildNodeID: UInt64 = 0

    public var missingValueTracksTrueChild: Bool = false

    public var evaluationInfo: [CoreML_Specification_TreeEnsembleParameters.TreeNode.EvaluationInfo] = []

    ///*
    /// The relative hit rate of a node for optimization purposes.
    ///
    /// This value has no effect on the accuracy of the result;
    /// it allows the tree to optimize for frequent branches.
    /// The value is relative,
    /// compared to the hit rates of other branch nodes.
    ///
    /// You typically use a proportion of training samples
    /// that reached this node
    /// or some similar metric to derive this value.
    public var relativeHitRate: Double = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum TreeNodeBehavior: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case branchOnValueLessThanEqual // = 0
      case branchOnValueLessThan // = 1
      case branchOnValueGreaterThanEqual // = 2
      case branchOnValueGreaterThan // = 3
      case branchOnValueEqual // = 4
      case branchOnValueNotEqual // = 5
      case leafNode // = 6
      case UNRECOGNIZED(Int)

      public init() {
        self = .branchOnValueLessThanEqual
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .branchOnValueLessThanEqual
        case 1: self = .branchOnValueLessThan
        case 2: self = .branchOnValueGreaterThanEqual
        case 3: self = .branchOnValueGreaterThan
        case 4: self = .branchOnValueEqual
        case 5: self = .branchOnValueNotEqual
        case 6: self = .leafNode
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .branchOnValueLessThanEqual: return 0
        case .branchOnValueLessThan: return 1
        case .branchOnValueGreaterThanEqual: return 2
        case .branchOnValueGreaterThan: return 3
        case .branchOnValueEqual: return 4
        case .branchOnValueNotEqual: return 5
        case .leafNode: return 6
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    ///*
    /// The leaf mode.
    ///
    /// If ``nodeBahavior`` == ``LeafNode``,
    /// then the evaluationValue is added to the base prediction value
    /// in order to get the final prediction.
    /// To support multiclass classification
    /// as well as regression and binary classification,
    /// the evaluation value is encoded here as a sparse vector,
    /// with evaluationIndex being the index of the base vector
    /// that evaluation value is added to.
    /// In the single class case,
    /// it is expected that evaluationIndex is exactly 0.
    public struct EvaluationInfo: SwiftProtobuf.Message {
      public static let protoMessageName: String = CoreML_Specification_TreeEnsembleParameters.TreeNode.protoMessageName + ".EvaluationInfo"

      public var evaluationIndex: UInt64 = 0

      public var evaluationValue: Double = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      /// Used by the decoding initializers in the SwiftProtobuf library, not generally
      /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
      /// initializers are defined in the SwiftProtobuf library. See the Message and
      /// Message+*Additions` files.
      public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
          switch fieldNumber {
          case 1: try decoder.decodeSingularUInt64Field(value: &self.evaluationIndex)
          case 2: try decoder.decodeSingularDoubleField(value: &self.evaluationValue)
          default: break
          }
        }
      }

      /// Used by the encoding methods of the SwiftProtobuf library, not generally
      /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
      /// other serializer methods are defined in the SwiftProtobuf library. See the
      /// `Message` and `Message+*Additions` files.
      public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if self.evaluationIndex != 0 {
          try visitor.visitSingularUInt64Field(value: self.evaluationIndex, fieldNumber: 1)
        }
        if self.evaluationValue != 0 {
          try visitor.visitSingularDoubleField(value: self.evaluationValue, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
      }
    }

    public init() {}

    /// Used by the decoding initializers in the SwiftProtobuf library, not generally
    /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
    /// initializers are defined in the SwiftProtobuf library. See the Message and
    /// Message+*Additions` files.
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt64Field(value: &self.treeID)
        case 2: try decoder.decodeSingularUInt64Field(value: &self.nodeID)
        case 3: try decoder.decodeSingularEnumField(value: &self.nodeBehavior)
        case 10: try decoder.decodeSingularUInt64Field(value: &self.branchFeatureIndex)
        case 11: try decoder.decodeSingularDoubleField(value: &self.branchFeatureValue)
        case 12: try decoder.decodeSingularUInt64Field(value: &self.trueChildNodeID)
        case 13: try decoder.decodeSingularUInt64Field(value: &self.falseChildNodeID)
        case 14: try decoder.decodeSingularBoolField(value: &self.missingValueTracksTrueChild)
        case 20: try decoder.decodeRepeatedMessageField(value: &self.evaluationInfo)
        case 30: try decoder.decodeSingularDoubleField(value: &self.relativeHitRate)
        default: break
        }
      }
    }

    /// Used by the encoding methods of the SwiftProtobuf library, not generally
    /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
    /// other serializer methods are defined in the SwiftProtobuf library. See the
    /// `Message` and `Message+*Additions` files.
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      if self.treeID != 0 {
        try visitor.visitSingularUInt64Field(value: self.treeID, fieldNumber: 1)
      }
      if self.nodeID != 0 {
        try visitor.visitSingularUInt64Field(value: self.nodeID, fieldNumber: 2)
      }
      if self.nodeBehavior != .branchOnValueLessThanEqual {
        try visitor.visitSingularEnumField(value: self.nodeBehavior, fieldNumber: 3)
      }
      if self.branchFeatureIndex != 0 {
        try visitor.visitSingularUInt64Field(value: self.branchFeatureIndex, fieldNumber: 10)
      }
      if self.branchFeatureValue != 0 {
        try visitor.visitSingularDoubleField(value: self.branchFeatureValue, fieldNumber: 11)
      }
      if self.trueChildNodeID != 0 {
        try visitor.visitSingularUInt64Field(value: self.trueChildNodeID, fieldNumber: 12)
      }
      if self.falseChildNodeID != 0 {
        try visitor.visitSingularUInt64Field(value: self.falseChildNodeID, fieldNumber: 13)
      }
      if self.missingValueTracksTrueChild != false {
        try visitor.visitSingularBoolField(value: self.missingValueTracksTrueChild, fieldNumber: 14)
      }
      if !self.evaluationInfo.isEmpty {
        try visitor.visitRepeatedMessageField(value: self.evaluationInfo, fieldNumber: 20)
      }
      if self.relativeHitRate != 0 {
        try visitor.visitSingularDoubleField(value: self.relativeHitRate, fieldNumber: 30)
      }
      try unknownFields.traverse(visitor: &visitor)
    }
  }

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.nodes)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.numPredictionDimensions)
      case 3: try decoder.decodeRepeatedDoubleField(value: &self.basePredictionValue)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nodes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodes, fieldNumber: 1)
    }
    if self.numPredictionDimensions != 0 {
      try visitor.visitSingularUInt64Field(value: self.numPredictionDimensions, fieldNumber: 2)
    }
    if !self.basePredictionValue.isEmpty {
      try visitor.visitPackedDoubleField(value: self.basePredictionValue, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// A tree ensemble classifier.
public struct CoreML_Specification_TreeEnsembleClassifier: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".TreeEnsembleClassifier"

  public var treeEnsemble: CoreML_Specification_TreeEnsembleParameters {
    get {return _storage._treeEnsemble ?? CoreML_Specification_TreeEnsembleParameters()}
    set {_uniqueStorage()._treeEnsemble = newValue}
  }
  /// Returns true if `treeEnsemble` has been explicitly set.
  public var hasTreeEnsemble: Bool {return _storage._treeEnsemble != nil}
  /// Clears the value of `treeEnsemble`. Subsequent reads from it will return its default value.
  public mutating func clearTreeEnsemble() {_storage._treeEnsemble = nil}

  public var postEvaluationTransform: CoreML_Specification_TreeEnsemblePostEvaluationTransform {
    get {return _storage._postEvaluationTransform}
    set {_uniqueStorage()._postEvaluationTransform = newValue}
  }

  /// Required class label mapping
  public var classLabels: OneOf_ClassLabels? {
    get {return _storage._classLabels}
    set {_uniqueStorage()._classLabels = newValue}
  }

  public var stringClassLabels: CoreML_Specification_StringVector {
    get {
      if case .stringClassLabels(let v)? = _storage._classLabels {return v}
      return CoreML_Specification_StringVector()
    }
    set {_uniqueStorage()._classLabels = .stringClassLabels(newValue)}
  }

  public var int64ClassLabels: CoreML_Specification_Int64Vector {
    get {
      if case .int64ClassLabels(let v)? = _storage._classLabels {return v}
      return CoreML_Specification_Int64Vector()
    }
    set {_uniqueStorage()._classLabels = .int64ClassLabels(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Required class label mapping
  public enum OneOf_ClassLabels: Equatable {
    case stringClassLabels(CoreML_Specification_StringVector)
    case int64ClassLabels(CoreML_Specification_Int64Vector)

    public static func ==(lhs: CoreML_Specification_TreeEnsembleClassifier.OneOf_ClassLabels, rhs: CoreML_Specification_TreeEnsembleClassifier.OneOf_ClassLabels) -> Bool {
      switch (lhs, rhs) {
      case (.stringClassLabels(let l), .stringClassLabels(let r)): return l == r
      case (.int64ClassLabels(let l), .int64ClassLabels(let r)): return l == r
      default: return false
      }
    }
  }

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._treeEnsemble)
        case 2: try decoder.decodeSingularEnumField(value: &_storage._postEvaluationTransform)
        case 100:
          var v: CoreML_Specification_StringVector?
          if let current = _storage._classLabels {
            try decoder.handleConflictingOneOf()
            if case .stringClassLabels(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._classLabels = .stringClassLabels(v)}
        case 101:
          var v: CoreML_Specification_Int64Vector?
          if let current = _storage._classLabels {
            try decoder.handleConflictingOneOf()
            if case .int64ClassLabels(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._classLabels = .int64ClassLabels(v)}
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._treeEnsemble {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._postEvaluationTransform != .noTransform {
        try visitor.visitSingularEnumField(value: _storage._postEvaluationTransform, fieldNumber: 2)
      }
      switch _storage._classLabels {
      case .stringClassLabels(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 100)
      case .int64ClassLabels(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// A tree ensemble regressor.
public struct CoreML_Specification_TreeEnsembleRegressor: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".TreeEnsembleRegressor"

  public var treeEnsemble: CoreML_Specification_TreeEnsembleParameters {
    get {return _storage._treeEnsemble ?? CoreML_Specification_TreeEnsembleParameters()}
    set {_uniqueStorage()._treeEnsemble = newValue}
  }
  /// Returns true if `treeEnsemble` has been explicitly set.
  public var hasTreeEnsemble: Bool {return _storage._treeEnsemble != nil}
  /// Clears the value of `treeEnsemble`. Subsequent reads from it will return its default value.
  public mutating func clearTreeEnsemble() {_storage._treeEnsemble = nil}

  public var postEvaluationTransform: CoreML_Specification_TreeEnsemblePostEvaluationTransform {
    get {return _storage._postEvaluationTransform}
    set {_uniqueStorage()._postEvaluationTransform = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._treeEnsemble)
        case 2: try decoder.decodeSingularEnumField(value: &_storage._postEvaluationTransform)
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._treeEnsemble {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._postEvaluationTransform != .noTransform {
        try visitor.visitSingularEnumField(value: _storage._postEvaluationTransform, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "CoreML.Specification"

extension CoreML_Specification_TreeEnsemblePostEvaluationTransform: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NoTransform"),
    1: .same(proto: "Classification_SoftMax"),
    2: .same(proto: "Regression_Logistic"),
    3: .same(proto: "Classification_SoftMaxWithZeroClassReference"),
  ]
}

extension CoreML_Specification_TreeEnsembleParameters: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nodes"),
    2: .same(proto: "numPredictionDimensions"),
    3: .same(proto: "basePredictionValue"),
  ]

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_TreeEnsembleParameters) -> Bool {
    if self.nodes != other.nodes {return false}
    if self.numPredictionDimensions != other.numPredictionDimensions {return false}
    if self.basePredictionValue != other.basePredictionValue {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_TreeEnsembleParameters.TreeNode: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "treeId"),
    2: .same(proto: "nodeId"),
    3: .same(proto: "nodeBehavior"),
    10: .same(proto: "branchFeatureIndex"),
    11: .same(proto: "branchFeatureValue"),
    12: .same(proto: "trueChildNodeId"),
    13: .same(proto: "falseChildNodeId"),
    14: .same(proto: "missingValueTracksTrueChild"),
    20: .same(proto: "evaluationInfo"),
    30: .same(proto: "relativeHitRate"),
  ]

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_TreeEnsembleParameters.TreeNode) -> Bool {
    if self.treeID != other.treeID {return false}
    if self.nodeID != other.nodeID {return false}
    if self.nodeBehavior != other.nodeBehavior {return false}
    if self.branchFeatureIndex != other.branchFeatureIndex {return false}
    if self.branchFeatureValue != other.branchFeatureValue {return false}
    if self.trueChildNodeID != other.trueChildNodeID {return false}
    if self.falseChildNodeID != other.falseChildNodeID {return false}
    if self.missingValueTracksTrueChild != other.missingValueTracksTrueChild {return false}
    if self.evaluationInfo != other.evaluationInfo {return false}
    if self.relativeHitRate != other.relativeHitRate {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_TreeEnsembleParameters.TreeNode.TreeNodeBehavior: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "BranchOnValueLessThanEqual"),
    1: .same(proto: "BranchOnValueLessThan"),
    2: .same(proto: "BranchOnValueGreaterThanEqual"),
    3: .same(proto: "BranchOnValueGreaterThan"),
    4: .same(proto: "BranchOnValueEqual"),
    5: .same(proto: "BranchOnValueNotEqual"),
    6: .same(proto: "LeafNode"),
  ]
}

extension CoreML_Specification_TreeEnsembleParameters.TreeNode.EvaluationInfo: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "evaluationIndex"),
    2: .same(proto: "evaluationValue"),
  ]

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_TreeEnsembleParameters.TreeNode.EvaluationInfo) -> Bool {
    if self.evaluationIndex != other.evaluationIndex {return false}
    if self.evaluationValue != other.evaluationValue {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_TreeEnsembleClassifier: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "treeEnsemble"),
    2: .same(proto: "postEvaluationTransform"),
    100: .same(proto: "stringClassLabels"),
    101: .same(proto: "int64ClassLabels"),
  ]

  fileprivate class _StorageClass {
    var _treeEnsemble: CoreML_Specification_TreeEnsembleParameters? = nil
    var _postEvaluationTransform: CoreML_Specification_TreeEnsemblePostEvaluationTransform = .noTransform
    var _classLabels: CoreML_Specification_TreeEnsembleClassifier.OneOf_ClassLabels?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _treeEnsemble = source._treeEnsemble
      _postEvaluationTransform = source._postEvaluationTransform
      _classLabels = source._classLabels
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_TreeEnsembleClassifier) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._treeEnsemble != other_storage._treeEnsemble {return false}
        if _storage._postEvaluationTransform != other_storage._postEvaluationTransform {return false}
        if _storage._classLabels != other_storage._classLabels {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_TreeEnsembleRegressor: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "treeEnsemble"),
    2: .same(proto: "postEvaluationTransform"),
  ]

  fileprivate class _StorageClass {
    var _treeEnsemble: CoreML_Specification_TreeEnsembleParameters? = nil
    var _postEvaluationTransform: CoreML_Specification_TreeEnsemblePostEvaluationTransform = .noTransform

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _treeEnsemble = source._treeEnsemble
      _postEvaluationTransform = source._postEvaluationTransform
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_TreeEnsembleRegressor) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._treeEnsemble != other_storage._treeEnsemble {return false}
        if _storage._postEvaluationTransform != other_storage._postEvaluationTransform {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}
