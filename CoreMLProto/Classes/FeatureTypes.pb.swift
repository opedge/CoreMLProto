// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: FeatureTypes.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

// Copyright (c) 2017, Apple Inc. All rights reserved.
//
// Use of this source code is governed by a BSD-3-clause license that can be
// found in LICENSE.txt or at https://opensource.org/licenses/BSD-3-Clause

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///*
/// The 64-bit integer feature type.
public struct CoreML_Specification_Int64FeatureType: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".Int64FeatureType"

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// The double-precision floating point number feature type.
public struct CoreML_Specification_DoubleFeatureType: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".DoubleFeatureType"

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// The string feature type.
public struct CoreML_Specification_StringFeatureType: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".StringFeatureType"

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// The image feature type.
public struct CoreML_Specification_ImageFeatureType: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".ImageFeatureType"

  public var width: Int64 = 0

  public var height: Int64 = 0

  public var colorSpace: CoreML_Specification_ImageFeatureType.ColorSpace = .invalidColorSpace

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Assumes raw (decompressed) format
  public enum ColorSpace: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case invalidColorSpace // = 0

    ///  8 bit pixel: 0=black, 255=white
    case grayscale // = 10

    /// 32 bit pixel: RGBA with A channel ignored
    case rgb // = 20

    /// 32 bit pixel: BGRA with A channel ignored
    case bgr // = 30
    case UNRECOGNIZED(Int)

    public init() {
      self = .invalidColorSpace
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .invalidColorSpace
      case 10: self = .grayscale
      case 20: self = .rgb
      case 30: self = .bgr
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .invalidColorSpace: return 0
      case .grayscale: return 10
      case .rgb: return 20
      case .bgr: return 30
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.width)
      case 2: try decoder.decodeSingularInt64Field(value: &self.height)
      case 3: try decoder.decodeSingularEnumField(value: &self.colorSpace)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.width != 0 {
      try visitor.visitSingularInt64Field(value: self.width, fieldNumber: 1)
    }
    if self.height != 0 {
      try visitor.visitSingularInt64Field(value: self.height, fieldNumber: 2)
    }
    if self.colorSpace != .invalidColorSpace {
      try visitor.visitSingularEnumField(value: self.colorSpace, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// The array feature type.
public struct CoreML_Specification_ArrayFeatureType: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".ArrayFeatureType"

  //// For neural networks, must be of length 1 or 3, representing input shape [C] or [C,H,W], respectively.
  public var shape: [Int64] = []

  public var dataType: CoreML_Specification_ArrayFeatureType.ArrayDataType = .invalidArrayDataType

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum ArrayDataType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case invalidArrayDataType // = 0

    /// 0x10000 | 32
    case float32 // = 65568

    /// 0x10000 | 64
    case double // = 65600

    /// 0x20000 | 32
    case int32 // = 131104
    case UNRECOGNIZED(Int)

    public init() {
      self = .invalidArrayDataType
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .invalidArrayDataType
      case 65568: self = .float32
      case 65600: self = .double
      case 131104: self = .int32
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .invalidArrayDataType: return 0
      case .float32: return 65568
      case .double: return 65600
      case .int32: return 131104
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedInt64Field(value: &self.shape)
      case 2: try decoder.decodeSingularEnumField(value: &self.dataType)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.shape.isEmpty {
      try visitor.visitPackedInt64Field(value: self.shape, fieldNumber: 1)
    }
    if self.dataType != .invalidArrayDataType {
      try visitor.visitSingularEnumField(value: self.dataType, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// The dictionary feature type.
public struct CoreML_Specification_DictionaryFeatureType: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".DictionaryFeatureType"

  ///*
  ///  Key/value type tags, with the following restrictions:
  ///  - ``keyType`` must be a hashable type
  ///  - ``valueType`` is assumed to be a ``double``
  public var keyType: OneOf_KeyType? {
    get {return _storage._keyType}
    set {_uniqueStorage()._keyType = newValue}
  }

  public var int64KeyType: CoreML_Specification_Int64FeatureType {
    get {
      if case .int64KeyType(let v)? = _storage._keyType {return v}
      return CoreML_Specification_Int64FeatureType()
    }
    set {_uniqueStorage()._keyType = .int64KeyType(newValue)}
  }

  public var stringKeyType: CoreML_Specification_StringFeatureType {
    get {
      if case .stringKeyType(let v)? = _storage._keyType {return v}
      return CoreML_Specification_StringFeatureType()
    }
    set {_uniqueStorage()._keyType = .stringKeyType(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  ///*
  ///  Key/value type tags, with the following restrictions:
  ///  - ``keyType`` must be a hashable type
  ///  - ``valueType`` is assumed to be a ``double``
  public enum OneOf_KeyType: Equatable {
    case int64KeyType(CoreML_Specification_Int64FeatureType)
    case stringKeyType(CoreML_Specification_StringFeatureType)

    public static func ==(lhs: CoreML_Specification_DictionaryFeatureType.OneOf_KeyType, rhs: CoreML_Specification_DictionaryFeatureType.OneOf_KeyType) -> Bool {
      switch (lhs, rhs) {
      case (.int64KeyType(let l), .int64KeyType(let r)): return l == r
      case (.stringKeyType(let l), .stringKeyType(let r)): return l == r
      default: return false
      }
    }
  }

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: CoreML_Specification_Int64FeatureType?
          if let current = _storage._keyType {
            try decoder.handleConflictingOneOf()
            if case .int64KeyType(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._keyType = .int64KeyType(v)}
        case 2:
          var v: CoreML_Specification_StringFeatureType?
          if let current = _storage._keyType {
            try decoder.handleConflictingOneOf()
            if case .stringKeyType(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._keyType = .stringKeyType(v)}
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._keyType {
      case .int64KeyType(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .stringKeyType(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// A feature, which may be optional.
public struct CoreML_Specification_FeatureType: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".FeatureType"

  public var type: OneOf_Type? {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  public var int64Type: CoreML_Specification_Int64FeatureType {
    get {
      if case .int64Type(let v)? = _storage._type {return v}
      return CoreML_Specification_Int64FeatureType()
    }
    set {_uniqueStorage()._type = .int64Type(newValue)}
  }

  public var doubleType: CoreML_Specification_DoubleFeatureType {
    get {
      if case .doubleType(let v)? = _storage._type {return v}
      return CoreML_Specification_DoubleFeatureType()
    }
    set {_uniqueStorage()._type = .doubleType(newValue)}
  }

  public var stringType: CoreML_Specification_StringFeatureType {
    get {
      if case .stringType(let v)? = _storage._type {return v}
      return CoreML_Specification_StringFeatureType()
    }
    set {_uniqueStorage()._type = .stringType(newValue)}
  }

  public var imageType: CoreML_Specification_ImageFeatureType {
    get {
      if case .imageType(let v)? = _storage._type {return v}
      return CoreML_Specification_ImageFeatureType()
    }
    set {_uniqueStorage()._type = .imageType(newValue)}
  }

  public var multiArrayType: CoreML_Specification_ArrayFeatureType {
    get {
      if case .multiArrayType(let v)? = _storage._type {return v}
      return CoreML_Specification_ArrayFeatureType()
    }
    set {_uniqueStorage()._type = .multiArrayType(newValue)}
  }

  public var dictionaryType: CoreML_Specification_DictionaryFeatureType {
    get {
      if case .dictionaryType(let v)? = _storage._type {return v}
      return CoreML_Specification_DictionaryFeatureType()
    }
    set {_uniqueStorage()._type = .dictionaryType(newValue)}
  }

  public var isOptional: Bool {
    get {return _storage._isOptional}
    set {_uniqueStorage()._isOptional = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Type: Equatable {
    case int64Type(CoreML_Specification_Int64FeatureType)
    case doubleType(CoreML_Specification_DoubleFeatureType)
    case stringType(CoreML_Specification_StringFeatureType)
    case imageType(CoreML_Specification_ImageFeatureType)
    case multiArrayType(CoreML_Specification_ArrayFeatureType)
    case dictionaryType(CoreML_Specification_DictionaryFeatureType)

    public static func ==(lhs: CoreML_Specification_FeatureType.OneOf_Type, rhs: CoreML_Specification_FeatureType.OneOf_Type) -> Bool {
      switch (lhs, rhs) {
      case (.int64Type(let l), .int64Type(let r)): return l == r
      case (.doubleType(let l), .doubleType(let r)): return l == r
      case (.stringType(let l), .stringType(let r)): return l == r
      case (.imageType(let l), .imageType(let r)): return l == r
      case (.multiArrayType(let l), .multiArrayType(let r)): return l == r
      case (.dictionaryType(let l), .dictionaryType(let r)): return l == r
      default: return false
      }
    }
  }

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: CoreML_Specification_Int64FeatureType?
          if let current = _storage._type {
            try decoder.handleConflictingOneOf()
            if case .int64Type(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._type = .int64Type(v)}
        case 2:
          var v: CoreML_Specification_DoubleFeatureType?
          if let current = _storage._type {
            try decoder.handleConflictingOneOf()
            if case .doubleType(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._type = .doubleType(v)}
        case 3:
          var v: CoreML_Specification_StringFeatureType?
          if let current = _storage._type {
            try decoder.handleConflictingOneOf()
            if case .stringType(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._type = .stringType(v)}
        case 4:
          var v: CoreML_Specification_ImageFeatureType?
          if let current = _storage._type {
            try decoder.handleConflictingOneOf()
            if case .imageType(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._type = .imageType(v)}
        case 5:
          var v: CoreML_Specification_ArrayFeatureType?
          if let current = _storage._type {
            try decoder.handleConflictingOneOf()
            if case .multiArrayType(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._type = .multiArrayType(v)}
        case 6:
          var v: CoreML_Specification_DictionaryFeatureType?
          if let current = _storage._type {
            try decoder.handleConflictingOneOf()
            if case .dictionaryType(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._type = .dictionaryType(v)}
        case 1000: try decoder.decodeSingularBoolField(value: &_storage._isOptional)
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._type {
      case .int64Type(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .doubleType(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .stringType(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .imageType(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case .multiArrayType(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case .dictionaryType(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      case nil: break
      }
      if _storage._isOptional != false {
        try visitor.visitSingularBoolField(value: _storage._isOptional, fieldNumber: 1000)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "CoreML.Specification"

extension CoreML_Specification_Int64FeatureType: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_Int64FeatureType) -> Bool {
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_DoubleFeatureType: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_DoubleFeatureType) -> Bool {
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_StringFeatureType: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_StringFeatureType) -> Bool {
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_ImageFeatureType: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "width"),
    2: .same(proto: "height"),
    3: .same(proto: "colorSpace"),
  ]

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_ImageFeatureType) -> Bool {
    if self.width != other.width {return false}
    if self.height != other.height {return false}
    if self.colorSpace != other.colorSpace {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_ImageFeatureType.ColorSpace: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INVALID_COLOR_SPACE"),
    10: .same(proto: "GRAYSCALE"),
    20: .same(proto: "RGB"),
    30: .same(proto: "BGR"),
  ]
}

extension CoreML_Specification_ArrayFeatureType: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shape"),
    2: .same(proto: "dataType"),
  ]

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_ArrayFeatureType) -> Bool {
    if self.shape != other.shape {return false}
    if self.dataType != other.dataType {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_ArrayFeatureType.ArrayDataType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INVALID_ARRAY_DATA_TYPE"),
    65568: .same(proto: "FLOAT32"),
    65600: .same(proto: "DOUBLE"),
    131104: .same(proto: "INT32"),
  ]
}

extension CoreML_Specification_DictionaryFeatureType: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "int64KeyType"),
    2: .same(proto: "stringKeyType"),
  ]

  fileprivate class _StorageClass {
    var _keyType: CoreML_Specification_DictionaryFeatureType.OneOf_KeyType?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _keyType = source._keyType
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_DictionaryFeatureType) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._keyType != other_storage._keyType {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_FeatureType: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "int64Type"),
    2: .same(proto: "doubleType"),
    3: .same(proto: "stringType"),
    4: .same(proto: "imageType"),
    5: .same(proto: "multiArrayType"),
    6: .same(proto: "dictionaryType"),
    1000: .same(proto: "isOptional"),
  ]

  fileprivate class _StorageClass {
    var _type: CoreML_Specification_FeatureType.OneOf_Type?
    var _isOptional: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _isOptional = source._isOptional
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_FeatureType) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._type != other_storage._type {return false}
        if _storage._isOptional != other_storage._isOptional {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}
