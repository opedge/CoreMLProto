// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: NeuralNetwork.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

// Copyright (c) 2017, Apple Inc. All rights reserved.
//
// Use of this source code is governed by a BSD-3-clause license that can be
// found in LICENSE.txt or at https://opensource.org/licenses/BSD-3-Clause

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///*
/// A neural network is defined through a collection of layers
/// and represents a directed acyclic graph (DAG).
/// Each layer has a name, a layer type,
/// a list of input names, a list of output names,
/// and a collection of parameters specific to the layer type.
///
/// The graph structure and connectivity of the neural network
/// is inferred from the input and output names.
/// A neural network starts with the layer
/// whose input name is equal to the value specified in
/// ``Model.description.input.name``,
/// and ends with the layer
/// whose output name is equal to the value specified in
/// ``Model.description.output.name``.
/// Layers must have unique input and output names,
/// and a layer may not have input or output names that
/// refer to layers that are not yet defined.
///
/// CoreML supports sequential data that can be 1- or 3-dimensional.
/// 3-dimensional data typically represents an image feature map,
/// whose shape is denoted by ``[C, H, W]``,
/// which corresponds to the channel, height, and width, respectively.
/// 1-dimensional data is a set of features
/// whose shape is denoted by ``[C]``,
/// and is equivalent to 3-dimensional data
/// with the shape ``[C, 1, 1]``.
///
/// For the purposes of this specification,
/// batch dimension is ignored.
/// Thus, a sequence of 3-dimensional data
/// is to be understood as a 4-dimensional array,
/// whose shape is denoted by ``[Seq_length, C, H, W]``,
/// and a sequence of 1-dimensional data
/// is to be understood as a 2-dimensional array,
/// whose shape is denoted by ``[Seq_length, C]``, 
/// which is equivalent to a 4-dimensional array
/// with the shape ``[Seq_length, C, 1, 1]``. This axes order is important to
/// remember while setting parameters for layers such as "reshape" and "permute".
///
/// 
/// At runtime, all data blobs are internally represented
/// as 5-dimensional blobs
/// with the shape ``[Seq_length, Batch, C, H, W]``.
///
/// A layer may process input data differently if operating over a sequence;
/// details of this behavior is documented in the layer's message.
/// Otherwise, sequential data is processed like a batch ---
/// that is, the sequence of inputs are processed independently and in parallel.
///
/// The network input shape specified by ``Model.description.input.type``
/// must be compatible with the expected input shape
/// of the network input layer, i.e. the last dimension is the fastest moving one.
///
/// All data blobs, as well as weight parameters,
/// are stored using row-major ordering, i.e. the last dimension is the fastest moving one.
public struct CoreML_Specification_NeuralNetwork: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".NeuralNetwork"

  public var layers: [CoreML_Specification_NeuralNetworkLayer] = []

  public var preprocessing: [CoreML_Specification_NeuralNetworkPreprocessing] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.layers)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.preprocessing)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.layers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.layers, fieldNumber: 1)
    }
    if !self.preprocessing.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.preprocessing, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// A neural network preprocessor that
/// performs a scalar multiplication of an image
/// followed by addition of scalar biases to the channels.
///
/// Input: X
///    An image in BGR or RGB format with shape ``[3, H, W]``
///    or in grayscale format with shape ``[1, H, W]``.
/// Output: Y
///    An image with format and shape corresponding to the input.
///
/// If the input image is in BGR format:
/// ::
///     Y[0, :, :] = channelScale * X[0, :, :] + blueBias
///     Y[1, :, :] = channelScale * X[1, :, :] + greenBias
///     Y[2, :, :] = channelScale * X[2, :, :] + redBias
///
/// If the input image is in RGB format:
/// ::
///     Y[0, :, :] = channelScale * X[0, :, :] + redBias
///     Y[1, :, :] = channelScale * X[1, :, :] + greenBias
///     Y[2, :, :] = channelScale * X[2, :, :] + blueBias
///
/// If the input image is in grayscale format:
/// ::
///     Y[0, :, :] = channelScale * X[0, :, :] + grayBias
public struct CoreML_Specification_NeuralNetworkImageScaler: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".NeuralNetworkImageScaler"

  ////Scalar to be multiplied.
  public var channelScale: Float = 0

  ////Scalar blue bias to be added.
  public var blueBias: Float = 0

  ////Scalar green bias to be added.
  public var greenBias: Float = 0

  ////Scalar red bias to be added.
  public var redBias: Float = 0

  ////Scalar bias to be added for grayscale images.
  public var grayBias: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 10: try decoder.decodeSingularFloatField(value: &self.channelScale)
      case 20: try decoder.decodeSingularFloatField(value: &self.blueBias)
      case 21: try decoder.decodeSingularFloatField(value: &self.greenBias)
      case 22: try decoder.decodeSingularFloatField(value: &self.redBias)
      case 30: try decoder.decodeSingularFloatField(value: &self.grayBias)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.channelScale != 0 {
      try visitor.visitSingularFloatField(value: self.channelScale, fieldNumber: 10)
    }
    if self.blueBias != 0 {
      try visitor.visitSingularFloatField(value: self.blueBias, fieldNumber: 20)
    }
    if self.greenBias != 0 {
      try visitor.visitSingularFloatField(value: self.greenBias, fieldNumber: 21)
    }
    if self.redBias != 0 {
      try visitor.visitSingularFloatField(value: self.redBias, fieldNumber: 22)
    }
    if self.grayBias != 0 {
      try visitor.visitSingularFloatField(value: self.grayBias, fieldNumber: 30)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// A neural network preprocessor that
/// subtracts the provided mean image from the input image.
/// The mean image is subtracted from the input named
/// ``NeuralNetworkPreprocessing.featureName``.
public struct CoreML_Specification_NeuralNetworkMeanImage: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".NeuralNetworkMeanImage"

  ///*
  /// Mean image stored as a flattened array of floats,
  /// representing shape [Channel,Height,Width].
  public var meanImage: [Float] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedFloatField(value: &self.meanImage)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.meanImage.isEmpty {
      try visitor.visitPackedFloatField(value: self.meanImage, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

//// Preprocessing parameters for image inputs.
public struct CoreML_Specification_NeuralNetworkPreprocessing: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".NeuralNetworkPreprocessing"

  //// must be equal to the input name to which the preprocessing is applied
  public var featureName: String {
    get {return _storage._featureName}
    set {_uniqueStorage()._featureName = newValue}
  }

  public var preprocessor: OneOf_Preprocessor? {
    get {return _storage._preprocessor}
    set {_uniqueStorage()._preprocessor = newValue}
  }

  public var scaler: CoreML_Specification_NeuralNetworkImageScaler {
    get {
      if case .scaler(let v)? = _storage._preprocessor {return v}
      return CoreML_Specification_NeuralNetworkImageScaler()
    }
    set {_uniqueStorage()._preprocessor = .scaler(newValue)}
  }

  public var meanImage: CoreML_Specification_NeuralNetworkMeanImage {
    get {
      if case .meanImage(let v)? = _storage._preprocessor {return v}
      return CoreML_Specification_NeuralNetworkMeanImage()
    }
    set {_uniqueStorage()._preprocessor = .meanImage(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Preprocessor: Equatable {
    case scaler(CoreML_Specification_NeuralNetworkImageScaler)
    case meanImage(CoreML_Specification_NeuralNetworkMeanImage)

    public static func ==(lhs: CoreML_Specification_NeuralNetworkPreprocessing.OneOf_Preprocessor, rhs: CoreML_Specification_NeuralNetworkPreprocessing.OneOf_Preprocessor) -> Bool {
      switch (lhs, rhs) {
      case (.scaler(let l), .scaler(let r)): return l == r
      case (.meanImage(let l), .meanImage(let r)): return l == r
      default: return false
      }
    }
  }

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._featureName)
        case 10:
          var v: CoreML_Specification_NeuralNetworkImageScaler?
          if let current = _storage._preprocessor {
            try decoder.handleConflictingOneOf()
            if case .scaler(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._preprocessor = .scaler(v)}
        case 11:
          var v: CoreML_Specification_NeuralNetworkMeanImage?
          if let current = _storage._preprocessor {
            try decoder.handleConflictingOneOf()
            if case .meanImage(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._preprocessor = .meanImage(v)}
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._featureName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._featureName, fieldNumber: 1)
      }
      switch _storage._preprocessor {
      case .scaler(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      case .meanImage(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// A rectified linear unit (ReLU) activation function.
///
/// This function has the following formula:
///
/// .. math::
///     f(x) = \text{max}(0, x)
public struct CoreML_Specification_ActivationReLU: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".ActivationReLU"

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// A leaky rectified linear unit (ReLU) activation function.
///
/// This function has the following formula:
///
/// .. math::
///     f(x) = \begin{cases}
///             x      & \text{if } x \geq 0 \\
///             \alpha x & \text{if } x < 0
///            \end{cases}
public struct CoreML_Specification_ActivationLeakyReLU: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".ActivationLeakyReLU"

  ///negative slope value for leakyReLU
  public var alpha: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularFloatField(value: &self.alpha)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.alpha != 0 {
      try visitor.visitSingularFloatField(value: self.alpha, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// A hyperbolic tangent activation function.
///
/// This function has the following formula:
///
/// .. math::
///     f(x) = \dfrac{1 - e^{-2x}}{1 + e^{-2x}}
public struct CoreML_Specification_ActivationTanh: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".ActivationTanh"

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// A scaled hyperbolic tangent activation function.
///
/// This function has the following formula:
///
/// .. math::
///     f(x) = \alpha \tanh(\beta x)
public struct CoreML_Specification_ActivationScaledTanh: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".ActivationScaledTanh"

  public var alpha: Float = 0

  public var beta: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularFloatField(value: &self.alpha)
      case 2: try decoder.decodeSingularFloatField(value: &self.beta)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.alpha != 0 {
      try visitor.visitSingularFloatField(value: self.alpha, fieldNumber: 1)
    }
    if self.beta != 0 {
      try visitor.visitSingularFloatField(value: self.beta, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// A sigmoid activation function.
///
/// This function has the following formula:
///
/// .. math::
///     f(x) = \dfrac{1}{1 + e^{-x}}
public struct CoreML_Specification_ActivationSigmoid: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".ActivationSigmoid"

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// A linear activation function.
///
/// This function has the following formula:
///
/// .. math::
///     f(x) = \alpha x + \beta
public struct CoreML_Specification_ActivationLinear: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".ActivationLinear"

  public var alpha: Float = 0

  public var beta: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularFloatField(value: &self.alpha)
      case 2: try decoder.decodeSingularFloatField(value: &self.beta)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.alpha != 0 {
      try visitor.visitSingularFloatField(value: self.alpha, fieldNumber: 1)
    }
    if self.beta != 0 {
      try visitor.visitSingularFloatField(value: self.beta, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// A hard sigmoid activation function.
///
/// This function has the following formula:
///
/// .. math::
///     f(x) = \text{min}(\text{max}(\alpha x + \beta, 0), 1)
public struct CoreML_Specification_ActivationSigmoidHard: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".ActivationSigmoidHard"

  public var alpha: Float = 0

  public var beta: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularFloatField(value: &self.alpha)
      case 2: try decoder.decodeSingularFloatField(value: &self.beta)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.alpha != 0 {
      try visitor.visitSingularFloatField(value: self.alpha, fieldNumber: 1)
    }
    if self.beta != 0 {
      try visitor.visitSingularFloatField(value: self.beta, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// A parameterized rectified linear unit (PReLU) activation function,
/// which takes ``[C]`` or ``[C,H,W]`` as an input and
/// applies different parameters in each channel dimension
/// (shared across the ``H`` and ``W`` components).
///
/// This function has the following formula:
///
/// .. math::
///    f(x_i) = \begin{cases}
///                 x_i          & \text{if } x_i \geq 0 \\
///                 \alpha_i x_i & \text{if } x_i < 0
///             \end{cases} \;,\;i=1,...,C
public struct CoreML_Specification_ActivationPReLU: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".ActivationPReLU"

  /// parameter of length C or 1.
  /// If length is 1, same value is used for all channels
  public var alpha: CoreML_Specification_WeightParams {
    get {return _storage._alpha ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._alpha = newValue}
  }
  /// Returns true if `alpha` has been explicitly set.
  public var hasAlpha: Bool {return _storage._alpha != nil}
  /// Clears the value of `alpha`. Subsequent reads from it will return its default value.
  public mutating func clearAlpha() {_storage._alpha = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._alpha)
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._alpha {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// An exponential linear unit (ELU) activation function.
///
/// This function has the following formula:
///
/// .. math::
///     f(x) = \begin{cases}
///             x              & \text{if } x \geq 0 \\
///             \alpha (e^x - 1) & \text{if } x < 0
///            \end{cases}
public struct CoreML_Specification_ActivationELU: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".ActivationELU"

  public var alpha: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularFloatField(value: &self.alpha)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.alpha != 0 {
      try visitor.visitSingularFloatField(value: self.alpha, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// A thresholded rectified linear unit (ReLU) activation function.
///
/// This function has the following formula:
///
/// .. math::
///     f(x) = \begin{cases}
///             x & \text{if } x \geq \alpha \\
///             0 & \text{if } x < \alpha
///            \end{cases}
public struct CoreML_Specification_ActivationThresholdedReLU: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".ActivationThresholdedReLU"

  public var alpha: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularFloatField(value: &self.alpha)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.alpha != 0 {
      try visitor.visitSingularFloatField(value: self.alpha, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// A softsign activation function.
///
/// This function has the following formula:
///
/// .. math::
///     f(x) = \dfrac{x}{1 + |x|}
public struct CoreML_Specification_ActivationSoftsign: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".ActivationSoftsign"

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// A softplus activation function.
///
/// This function has the following formula:
///
/// .. math::
///     f(x) = \text{log}(1 + e^x)
public struct CoreML_Specification_ActivationSoftplus: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".ActivationSoftplus"

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// A parametric softplus activation function,
/// which takes ``[C]`` or ``[C,H,W]`` as an input and
/// applies different parameters in each channel dimension
/// (shared across the ``H`` and ``W`` components).
///
/// This function has the following formula:
///
/// .. math::
///     f(x_i) = \alpha_i \text{log}(1 + e^{\beta_i x_i}) \;,\;i=1,...,C
public struct CoreML_Specification_ActivationParametricSoftplus: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".ActivationParametricSoftplus"

  /// If length is 1, same value is used for all channels
  public var alpha: CoreML_Specification_WeightParams {
    get {return _storage._alpha ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._alpha = newValue}
  }
  /// Returns true if `alpha` has been explicitly set.
  public var hasAlpha: Bool {return _storage._alpha != nil}
  /// Clears the value of `alpha`. Subsequent reads from it will return its default value.
  public mutating func clearAlpha() {_storage._alpha = nil}

  ///parameter of length C or 1
  public var beta: CoreML_Specification_WeightParams {
    get {return _storage._beta ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._beta = newValue}
  }
  /// Returns true if `beta` has been explicitly set.
  public var hasBeta: Bool {return _storage._beta != nil}
  /// Clears the value of `beta`. Subsequent reads from it will return its default value.
  public mutating func clearBeta() {_storage._beta = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._alpha)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._beta)
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._alpha {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._beta {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct CoreML_Specification_ActivationParams: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".ActivationParams"

  public var nonlinearityType: OneOf_NonlinearityType? {
    get {return _storage._nonlinearityType}
    set {_uniqueStorage()._nonlinearityType = newValue}
  }

  public var linear: CoreML_Specification_ActivationLinear {
    get {
      if case .linear(let v)? = _storage._nonlinearityType {return v}
      return CoreML_Specification_ActivationLinear()
    }
    set {_uniqueStorage()._nonlinearityType = .linear(newValue)}
  }

  public var reLu: CoreML_Specification_ActivationReLU {
    get {
      if case .reLu(let v)? = _storage._nonlinearityType {return v}
      return CoreML_Specification_ActivationReLU()
    }
    set {_uniqueStorage()._nonlinearityType = .reLu(newValue)}
  }

  public var leakyReLu: CoreML_Specification_ActivationLeakyReLU {
    get {
      if case .leakyReLu(let v)? = _storage._nonlinearityType {return v}
      return CoreML_Specification_ActivationLeakyReLU()
    }
    set {_uniqueStorage()._nonlinearityType = .leakyReLu(newValue)}
  }

  public var thresholdedReLu: CoreML_Specification_ActivationThresholdedReLU {
    get {
      if case .thresholdedReLu(let v)? = _storage._nonlinearityType {return v}
      return CoreML_Specification_ActivationThresholdedReLU()
    }
    set {_uniqueStorage()._nonlinearityType = .thresholdedReLu(newValue)}
  }

  public var preLu: CoreML_Specification_ActivationPReLU {
    get {
      if case .preLu(let v)? = _storage._nonlinearityType {return v}
      return CoreML_Specification_ActivationPReLU()
    }
    set {_uniqueStorage()._nonlinearityType = .preLu(newValue)}
  }

  public var tanh: CoreML_Specification_ActivationTanh {
    get {
      if case .tanh(let v)? = _storage._nonlinearityType {return v}
      return CoreML_Specification_ActivationTanh()
    }
    set {_uniqueStorage()._nonlinearityType = .tanh(newValue)}
  }

  public var scaledTanh: CoreML_Specification_ActivationScaledTanh {
    get {
      if case .scaledTanh(let v)? = _storage._nonlinearityType {return v}
      return CoreML_Specification_ActivationScaledTanh()
    }
    set {_uniqueStorage()._nonlinearityType = .scaledTanh(newValue)}
  }

  public var sigmoid: CoreML_Specification_ActivationSigmoid {
    get {
      if case .sigmoid(let v)? = _storage._nonlinearityType {return v}
      return CoreML_Specification_ActivationSigmoid()
    }
    set {_uniqueStorage()._nonlinearityType = .sigmoid(newValue)}
  }

  public var sigmoidHard: CoreML_Specification_ActivationSigmoidHard {
    get {
      if case .sigmoidHard(let v)? = _storage._nonlinearityType {return v}
      return CoreML_Specification_ActivationSigmoidHard()
    }
    set {_uniqueStorage()._nonlinearityType = .sigmoidHard(newValue)}
  }

  public var elu: CoreML_Specification_ActivationELU {
    get {
      if case .elu(let v)? = _storage._nonlinearityType {return v}
      return CoreML_Specification_ActivationELU()
    }
    set {_uniqueStorage()._nonlinearityType = .elu(newValue)}
  }

  public var softsign: CoreML_Specification_ActivationSoftsign {
    get {
      if case .softsign(let v)? = _storage._nonlinearityType {return v}
      return CoreML_Specification_ActivationSoftsign()
    }
    set {_uniqueStorage()._nonlinearityType = .softsign(newValue)}
  }

  public var softplus: CoreML_Specification_ActivationSoftplus {
    get {
      if case .softplus(let v)? = _storage._nonlinearityType {return v}
      return CoreML_Specification_ActivationSoftplus()
    }
    set {_uniqueStorage()._nonlinearityType = .softplus(newValue)}
  }

  public var parametricSoftplus: CoreML_Specification_ActivationParametricSoftplus {
    get {
      if case .parametricSoftplus(let v)? = _storage._nonlinearityType {return v}
      return CoreML_Specification_ActivationParametricSoftplus()
    }
    set {_uniqueStorage()._nonlinearityType = .parametricSoftplus(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_NonlinearityType: Equatable {
    case linear(CoreML_Specification_ActivationLinear)
    case reLu(CoreML_Specification_ActivationReLU)
    case leakyReLu(CoreML_Specification_ActivationLeakyReLU)
    case thresholdedReLu(CoreML_Specification_ActivationThresholdedReLU)
    case preLu(CoreML_Specification_ActivationPReLU)
    case tanh(CoreML_Specification_ActivationTanh)
    case scaledTanh(CoreML_Specification_ActivationScaledTanh)
    case sigmoid(CoreML_Specification_ActivationSigmoid)
    case sigmoidHard(CoreML_Specification_ActivationSigmoidHard)
    case elu(CoreML_Specification_ActivationELU)
    case softsign(CoreML_Specification_ActivationSoftsign)
    case softplus(CoreML_Specification_ActivationSoftplus)
    case parametricSoftplus(CoreML_Specification_ActivationParametricSoftplus)

    public static func ==(lhs: CoreML_Specification_ActivationParams.OneOf_NonlinearityType, rhs: CoreML_Specification_ActivationParams.OneOf_NonlinearityType) -> Bool {
      switch (lhs, rhs) {
      case (.linear(let l), .linear(let r)): return l == r
      case (.reLu(let l), .reLu(let r)): return l == r
      case (.leakyReLu(let l), .leakyReLu(let r)): return l == r
      case (.thresholdedReLu(let l), .thresholdedReLu(let r)): return l == r
      case (.preLu(let l), .preLu(let r)): return l == r
      case (.tanh(let l), .tanh(let r)): return l == r
      case (.scaledTanh(let l), .scaledTanh(let r)): return l == r
      case (.sigmoid(let l), .sigmoid(let r)): return l == r
      case (.sigmoidHard(let l), .sigmoidHard(let r)): return l == r
      case (.elu(let l), .elu(let r)): return l == r
      case (.softsign(let l), .softsign(let r)): return l == r
      case (.softplus(let l), .softplus(let r)): return l == r
      case (.parametricSoftplus(let l), .parametricSoftplus(let r)): return l == r
      default: return false
      }
    }
  }

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 5:
          var v: CoreML_Specification_ActivationLinear?
          if let current = _storage._nonlinearityType {
            try decoder.handleConflictingOneOf()
            if case .linear(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._nonlinearityType = .linear(v)}
        case 10:
          var v: CoreML_Specification_ActivationReLU?
          if let current = _storage._nonlinearityType {
            try decoder.handleConflictingOneOf()
            if case .reLu(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._nonlinearityType = .reLu(v)}
        case 15:
          var v: CoreML_Specification_ActivationLeakyReLU?
          if let current = _storage._nonlinearityType {
            try decoder.handleConflictingOneOf()
            if case .leakyReLu(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._nonlinearityType = .leakyReLu(v)}
        case 20:
          var v: CoreML_Specification_ActivationThresholdedReLU?
          if let current = _storage._nonlinearityType {
            try decoder.handleConflictingOneOf()
            if case .thresholdedReLu(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._nonlinearityType = .thresholdedReLu(v)}
        case 25:
          var v: CoreML_Specification_ActivationPReLU?
          if let current = _storage._nonlinearityType {
            try decoder.handleConflictingOneOf()
            if case .preLu(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._nonlinearityType = .preLu(v)}
        case 30:
          var v: CoreML_Specification_ActivationTanh?
          if let current = _storage._nonlinearityType {
            try decoder.handleConflictingOneOf()
            if case .tanh(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._nonlinearityType = .tanh(v)}
        case 31:
          var v: CoreML_Specification_ActivationScaledTanh?
          if let current = _storage._nonlinearityType {
            try decoder.handleConflictingOneOf()
            if case .scaledTanh(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._nonlinearityType = .scaledTanh(v)}
        case 40:
          var v: CoreML_Specification_ActivationSigmoid?
          if let current = _storage._nonlinearityType {
            try decoder.handleConflictingOneOf()
            if case .sigmoid(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._nonlinearityType = .sigmoid(v)}
        case 41:
          var v: CoreML_Specification_ActivationSigmoidHard?
          if let current = _storage._nonlinearityType {
            try decoder.handleConflictingOneOf()
            if case .sigmoidHard(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._nonlinearityType = .sigmoidHard(v)}
        case 50:
          var v: CoreML_Specification_ActivationELU?
          if let current = _storage._nonlinearityType {
            try decoder.handleConflictingOneOf()
            if case .elu(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._nonlinearityType = .elu(v)}
        case 60:
          var v: CoreML_Specification_ActivationSoftsign?
          if let current = _storage._nonlinearityType {
            try decoder.handleConflictingOneOf()
            if case .softsign(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._nonlinearityType = .softsign(v)}
        case 70:
          var v: CoreML_Specification_ActivationSoftplus?
          if let current = _storage._nonlinearityType {
            try decoder.handleConflictingOneOf()
            if case .softplus(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._nonlinearityType = .softplus(v)}
        case 71:
          var v: CoreML_Specification_ActivationParametricSoftplus?
          if let current = _storage._nonlinearityType {
            try decoder.handleConflictingOneOf()
            if case .parametricSoftplus(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._nonlinearityType = .parametricSoftplus(v)}
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._nonlinearityType {
      case .linear(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case .reLu(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      case .leakyReLu(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      case .thresholdedReLu(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      case .preLu(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      case .tanh(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
      case .scaledTanh(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
      case .sigmoid(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 40)
      case .sigmoidHard(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 41)
      case .elu(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 50)
      case .softsign(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 60)
      case .softplus(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 70)
      case .parametricSoftplus(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 71)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// A single neural network layer.
public struct CoreML_Specification_NeuralNetworkLayer: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".NeuralNetworkLayer"

  ///descriptive name of the layer
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var input: [String] {
    get {return _storage._input}
    set {_uniqueStorage()._input = newValue}
  }

  public var output: [String] {
    get {return _storage._output}
    set {_uniqueStorage()._output = newValue}
  }

  public var layer: OneOf_Layer? {
    get {return _storage._layer}
    set {_uniqueStorage()._layer = newValue}
  }

  /// start at 100 here
  public var convolution: CoreML_Specification_ConvolutionLayerParams {
    get {
      if case .convolution(let v)? = _storage._layer {return v}
      return CoreML_Specification_ConvolutionLayerParams()
    }
    set {_uniqueStorage()._layer = .convolution(newValue)}
  }

  public var pooling: CoreML_Specification_PoolingLayerParams {
    get {
      if case .pooling(let v)? = _storage._layer {return v}
      return CoreML_Specification_PoolingLayerParams()
    }
    set {_uniqueStorage()._layer = .pooling(newValue)}
  }

  public var activation: CoreML_Specification_ActivationParams {
    get {
      if case .activation(let v)? = _storage._layer {return v}
      return CoreML_Specification_ActivationParams()
    }
    set {_uniqueStorage()._layer = .activation(newValue)}
  }

  public var innerProduct: CoreML_Specification_InnerProductLayerParams {
    get {
      if case .innerProduct(let v)? = _storage._layer {return v}
      return CoreML_Specification_InnerProductLayerParams()
    }
    set {_uniqueStorage()._layer = .innerProduct(newValue)}
  }

  public var embedding: CoreML_Specification_EmbeddingLayerParams {
    get {
      if case .embedding(let v)? = _storage._layer {return v}
      return CoreML_Specification_EmbeddingLayerParams()
    }
    set {_uniqueStorage()._layer = .embedding(newValue)}
  }

  ///normalization related layers
  public var batchnorm: CoreML_Specification_BatchnormLayerParams {
    get {
      if case .batchnorm(let v)? = _storage._layer {return v}
      return CoreML_Specification_BatchnormLayerParams()
    }
    set {_uniqueStorage()._layer = .batchnorm(newValue)}
  }

  public var mvn: CoreML_Specification_MeanVarianceNormalizeLayerParams {
    get {
      if case .mvn(let v)? = _storage._layer {return v}
      return CoreML_Specification_MeanVarianceNormalizeLayerParams()
    }
    set {_uniqueStorage()._layer = .mvn(newValue)}
  }

  public var l2Normalize: CoreML_Specification_L2NormalizeLayerParams {
    get {
      if case .l2Normalize(let v)? = _storage._layer {return v}
      return CoreML_Specification_L2NormalizeLayerParams()
    }
    set {_uniqueStorage()._layer = .l2Normalize(newValue)}
  }

  public var softmax: CoreML_Specification_SoftmaxLayerParams {
    get {
      if case .softmax(let v)? = _storage._layer {return v}
      return CoreML_Specification_SoftmaxLayerParams()
    }
    set {_uniqueStorage()._layer = .softmax(newValue)}
  }

  public var lrn: CoreML_Specification_LRNLayerParams {
    get {
      if case .lrn(let v)? = _storage._layer {return v}
      return CoreML_Specification_LRNLayerParams()
    }
    set {_uniqueStorage()._layer = .lrn(newValue)}
  }

  public var crop: CoreML_Specification_CropLayerParams {
    get {
      if case .crop(let v)? = _storage._layer {return v}
      return CoreML_Specification_CropLayerParams()
    }
    set {_uniqueStorage()._layer = .crop(newValue)}
  }

  public var padding: CoreML_Specification_PaddingLayerParams {
    get {
      if case .padding(let v)? = _storage._layer {return v}
      return CoreML_Specification_PaddingLayerParams()
    }
    set {_uniqueStorage()._layer = .padding(newValue)}
  }

  public var upsample: CoreML_Specification_UpsampleLayerParams {
    get {
      if case .upsample(let v)? = _storage._layer {return v}
      return CoreML_Specification_UpsampleLayerParams()
    }
    set {_uniqueStorage()._layer = .upsample(newValue)}
  }

  public var unary: CoreML_Specification_UnaryFunctionLayerParams {
    get {
      if case .unary(let v)? = _storage._layer {return v}
      return CoreML_Specification_UnaryFunctionLayerParams()
    }
    set {_uniqueStorage()._layer = .unary(newValue)}
  }

  ///elementwise operations
  public var add: CoreML_Specification_AddLayerParams {
    get {
      if case .add(let v)? = _storage._layer {return v}
      return CoreML_Specification_AddLayerParams()
    }
    set {_uniqueStorage()._layer = .add(newValue)}
  }

  public var multiply: CoreML_Specification_MultiplyLayerParams {
    get {
      if case .multiply(let v)? = _storage._layer {return v}
      return CoreML_Specification_MultiplyLayerParams()
    }
    set {_uniqueStorage()._layer = .multiply(newValue)}
  }

  public var average: CoreML_Specification_AverageLayerParams {
    get {
      if case .average(let v)? = _storage._layer {return v}
      return CoreML_Specification_AverageLayerParams()
    }
    set {_uniqueStorage()._layer = .average(newValue)}
  }

  public var scale: CoreML_Specification_ScaleLayerParams {
    get {
      if case .scale(let v)? = _storage._layer {return v}
      return CoreML_Specification_ScaleLayerParams()
    }
    set {_uniqueStorage()._layer = .scale(newValue)}
  }

  public var bias: CoreML_Specification_BiasLayerParams {
    get {
      if case .bias(let v)? = _storage._layer {return v}
      return CoreML_Specification_BiasLayerParams()
    }
    set {_uniqueStorage()._layer = .bias(newValue)}
  }

  public var max: CoreML_Specification_MaxLayerParams {
    get {
      if case .max(let v)? = _storage._layer {return v}
      return CoreML_Specification_MaxLayerParams()
    }
    set {_uniqueStorage()._layer = .max(newValue)}
  }

  public var min: CoreML_Specification_MinLayerParams {
    get {
      if case .min(let v)? = _storage._layer {return v}
      return CoreML_Specification_MinLayerParams()
    }
    set {_uniqueStorage()._layer = .min(newValue)}
  }

  public var dot: CoreML_Specification_DotProductLayerParams {
    get {
      if case .dot(let v)? = _storage._layer {return v}
      return CoreML_Specification_DotProductLayerParams()
    }
    set {_uniqueStorage()._layer = .dot(newValue)}
  }

  public var reduce: CoreML_Specification_ReduceLayerParams {
    get {
      if case .reduce(let v)? = _storage._layer {return v}
      return CoreML_Specification_ReduceLayerParams()
    }
    set {_uniqueStorage()._layer = .reduce(newValue)}
  }

  public var loadConstant: CoreML_Specification_LoadConstantLayerParams {
    get {
      if case .loadConstant(let v)? = _storage._layer {return v}
      return CoreML_Specification_LoadConstantLayerParams()
    }
    set {_uniqueStorage()._layer = .loadConstant(newValue)}
  }

  ///data reorganization
  public var reshape: CoreML_Specification_ReshapeLayerParams {
    get {
      if case .reshape(let v)? = _storage._layer {return v}
      return CoreML_Specification_ReshapeLayerParams()
    }
    set {_uniqueStorage()._layer = .reshape(newValue)}
  }

  public var flatten: CoreML_Specification_FlattenLayerParams {
    get {
      if case .flatten(let v)? = _storage._layer {return v}
      return CoreML_Specification_FlattenLayerParams()
    }
    set {_uniqueStorage()._layer = .flatten(newValue)}
  }

  public var permute: CoreML_Specification_PermuteLayerParams {
    get {
      if case .permute(let v)? = _storage._layer {return v}
      return CoreML_Specification_PermuteLayerParams()
    }
    set {_uniqueStorage()._layer = .permute(newValue)}
  }

  public var concat: CoreML_Specification_ConcatLayerParams {
    get {
      if case .concat(let v)? = _storage._layer {return v}
      return CoreML_Specification_ConcatLayerParams()
    }
    set {_uniqueStorage()._layer = .concat(newValue)}
  }

  public var split: CoreML_Specification_SplitLayerParams {
    get {
      if case .split(let v)? = _storage._layer {return v}
      return CoreML_Specification_SplitLayerParams()
    }
    set {_uniqueStorage()._layer = .split(newValue)}
  }

  public var sequenceRepeat: CoreML_Specification_SequenceRepeatLayerParams {
    get {
      if case .sequenceRepeat(let v)? = _storage._layer {return v}
      return CoreML_Specification_SequenceRepeatLayerParams()
    }
    set {_uniqueStorage()._layer = .sequenceRepeat(newValue)}
  }

  public var reorganizeData: CoreML_Specification_ReorganizeDataLayerParams {
    get {
      if case .reorganizeData(let v)? = _storage._layer {return v}
      return CoreML_Specification_ReorganizeDataLayerParams()
    }
    set {_uniqueStorage()._layer = .reorganizeData(newValue)}
  }

  public var slice: CoreML_Specification_SliceLayerParams {
    get {
      if case .slice(let v)? = _storage._layer {return v}
      return CoreML_Specification_SliceLayerParams()
    }
    set {_uniqueStorage()._layer = .slice(newValue)}
  }

  ///Recurrent Layers
  public var simpleRecurrent: CoreML_Specification_SimpleRecurrentLayerParams {
    get {
      if case .simpleRecurrent(let v)? = _storage._layer {return v}
      return CoreML_Specification_SimpleRecurrentLayerParams()
    }
    set {_uniqueStorage()._layer = .simpleRecurrent(newValue)}
  }

  public var gru: CoreML_Specification_GRULayerParams {
    get {
      if case .gru(let v)? = _storage._layer {return v}
      return CoreML_Specification_GRULayerParams()
    }
    set {_uniqueStorage()._layer = .gru(newValue)}
  }

  public var uniDirectionalLstm: CoreML_Specification_UniDirectionalLSTMLayerParams {
    get {
      if case .uniDirectionalLstm(let v)? = _storage._layer {return v}
      return CoreML_Specification_UniDirectionalLSTMLayerParams()
    }
    set {_uniqueStorage()._layer = .uniDirectionalLstm(newValue)}
  }

  public var biDirectionalLstm: CoreML_Specification_BiDirectionalLSTMLayerParams {
    get {
      if case .biDirectionalLstm(let v)? = _storage._layer {return v}
      return CoreML_Specification_BiDirectionalLSTMLayerParams()
    }
    set {_uniqueStorage()._layer = .biDirectionalLstm(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Layer: Equatable {
    /// start at 100 here
    case convolution(CoreML_Specification_ConvolutionLayerParams)
    case pooling(CoreML_Specification_PoolingLayerParams)
    case activation(CoreML_Specification_ActivationParams)
    case innerProduct(CoreML_Specification_InnerProductLayerParams)
    case embedding(CoreML_Specification_EmbeddingLayerParams)
    ///normalization related layers
    case batchnorm(CoreML_Specification_BatchnormLayerParams)
    case mvn(CoreML_Specification_MeanVarianceNormalizeLayerParams)
    case l2Normalize(CoreML_Specification_L2NormalizeLayerParams)
    case softmax(CoreML_Specification_SoftmaxLayerParams)
    case lrn(CoreML_Specification_LRNLayerParams)
    case crop(CoreML_Specification_CropLayerParams)
    case padding(CoreML_Specification_PaddingLayerParams)
    case upsample(CoreML_Specification_UpsampleLayerParams)
    case unary(CoreML_Specification_UnaryFunctionLayerParams)
    ///elementwise operations
    case add(CoreML_Specification_AddLayerParams)
    case multiply(CoreML_Specification_MultiplyLayerParams)
    case average(CoreML_Specification_AverageLayerParams)
    case scale(CoreML_Specification_ScaleLayerParams)
    case bias(CoreML_Specification_BiasLayerParams)
    case max(CoreML_Specification_MaxLayerParams)
    case min(CoreML_Specification_MinLayerParams)
    case dot(CoreML_Specification_DotProductLayerParams)
    case reduce(CoreML_Specification_ReduceLayerParams)
    case loadConstant(CoreML_Specification_LoadConstantLayerParams)
    ///data reorganization
    case reshape(CoreML_Specification_ReshapeLayerParams)
    case flatten(CoreML_Specification_FlattenLayerParams)
    case permute(CoreML_Specification_PermuteLayerParams)
    case concat(CoreML_Specification_ConcatLayerParams)
    case split(CoreML_Specification_SplitLayerParams)
    case sequenceRepeat(CoreML_Specification_SequenceRepeatLayerParams)
    case reorganizeData(CoreML_Specification_ReorganizeDataLayerParams)
    case slice(CoreML_Specification_SliceLayerParams)
    ///Recurrent Layers
    case simpleRecurrent(CoreML_Specification_SimpleRecurrentLayerParams)
    case gru(CoreML_Specification_GRULayerParams)
    case uniDirectionalLstm(CoreML_Specification_UniDirectionalLSTMLayerParams)
    case biDirectionalLstm(CoreML_Specification_BiDirectionalLSTMLayerParams)

    public static func ==(lhs: CoreML_Specification_NeuralNetworkLayer.OneOf_Layer, rhs: CoreML_Specification_NeuralNetworkLayer.OneOf_Layer) -> Bool {
      switch (lhs, rhs) {
      case (.convolution(let l), .convolution(let r)): return l == r
      case (.pooling(let l), .pooling(let r)): return l == r
      case (.activation(let l), .activation(let r)): return l == r
      case (.innerProduct(let l), .innerProduct(let r)): return l == r
      case (.embedding(let l), .embedding(let r)): return l == r
      case (.batchnorm(let l), .batchnorm(let r)): return l == r
      case (.mvn(let l), .mvn(let r)): return l == r
      case (.l2Normalize(let l), .l2Normalize(let r)): return l == r
      case (.softmax(let l), .softmax(let r)): return l == r
      case (.lrn(let l), .lrn(let r)): return l == r
      case (.crop(let l), .crop(let r)): return l == r
      case (.padding(let l), .padding(let r)): return l == r
      case (.upsample(let l), .upsample(let r)): return l == r
      case (.unary(let l), .unary(let r)): return l == r
      case (.add(let l), .add(let r)): return l == r
      case (.multiply(let l), .multiply(let r)): return l == r
      case (.average(let l), .average(let r)): return l == r
      case (.scale(let l), .scale(let r)): return l == r
      case (.bias(let l), .bias(let r)): return l == r
      case (.max(let l), .max(let r)): return l == r
      case (.min(let l), .min(let r)): return l == r
      case (.dot(let l), .dot(let r)): return l == r
      case (.reduce(let l), .reduce(let r)): return l == r
      case (.loadConstant(let l), .loadConstant(let r)): return l == r
      case (.reshape(let l), .reshape(let r)): return l == r
      case (.flatten(let l), .flatten(let r)): return l == r
      case (.permute(let l), .permute(let r)): return l == r
      case (.concat(let l), .concat(let r)): return l == r
      case (.split(let l), .split(let r)): return l == r
      case (.sequenceRepeat(let l), .sequenceRepeat(let r)): return l == r
      case (.reorganizeData(let l), .reorganizeData(let r)): return l == r
      case (.slice(let l), .slice(let r)): return l == r
      case (.simpleRecurrent(let l), .simpleRecurrent(let r)): return l == r
      case (.gru(let l), .gru(let r)): return l == r
      case (.uniDirectionalLstm(let l), .uniDirectionalLstm(let r)): return l == r
      case (.biDirectionalLstm(let l), .biDirectionalLstm(let r)): return l == r
      default: return false
      }
    }
  }

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._name)
        case 2: try decoder.decodeRepeatedStringField(value: &_storage._input)
        case 3: try decoder.decodeRepeatedStringField(value: &_storage._output)
        case 100:
          var v: CoreML_Specification_ConvolutionLayerParams?
          if let current = _storage._layer {
            try decoder.handleConflictingOneOf()
            if case .convolution(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._layer = .convolution(v)}
        case 120:
          var v: CoreML_Specification_PoolingLayerParams?
          if let current = _storage._layer {
            try decoder.handleConflictingOneOf()
            if case .pooling(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._layer = .pooling(v)}
        case 130:
          var v: CoreML_Specification_ActivationParams?
          if let current = _storage._layer {
            try decoder.handleConflictingOneOf()
            if case .activation(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._layer = .activation(v)}
        case 140:
          var v: CoreML_Specification_InnerProductLayerParams?
          if let current = _storage._layer {
            try decoder.handleConflictingOneOf()
            if case .innerProduct(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._layer = .innerProduct(v)}
        case 150:
          var v: CoreML_Specification_EmbeddingLayerParams?
          if let current = _storage._layer {
            try decoder.handleConflictingOneOf()
            if case .embedding(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._layer = .embedding(v)}
        case 160:
          var v: CoreML_Specification_BatchnormLayerParams?
          if let current = _storage._layer {
            try decoder.handleConflictingOneOf()
            if case .batchnorm(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._layer = .batchnorm(v)}
        case 165:
          var v: CoreML_Specification_MeanVarianceNormalizeLayerParams?
          if let current = _storage._layer {
            try decoder.handleConflictingOneOf()
            if case .mvn(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._layer = .mvn(v)}
        case 170:
          var v: CoreML_Specification_L2NormalizeLayerParams?
          if let current = _storage._layer {
            try decoder.handleConflictingOneOf()
            if case .l2Normalize(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._layer = .l2Normalize(v)}
        case 175:
          var v: CoreML_Specification_SoftmaxLayerParams?
          if let current = _storage._layer {
            try decoder.handleConflictingOneOf()
            if case .softmax(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._layer = .softmax(v)}
        case 180:
          var v: CoreML_Specification_LRNLayerParams?
          if let current = _storage._layer {
            try decoder.handleConflictingOneOf()
            if case .lrn(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._layer = .lrn(v)}
        case 190:
          var v: CoreML_Specification_CropLayerParams?
          if let current = _storage._layer {
            try decoder.handleConflictingOneOf()
            if case .crop(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._layer = .crop(v)}
        case 200:
          var v: CoreML_Specification_PaddingLayerParams?
          if let current = _storage._layer {
            try decoder.handleConflictingOneOf()
            if case .padding(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._layer = .padding(v)}
        case 210:
          var v: CoreML_Specification_UpsampleLayerParams?
          if let current = _storage._layer {
            try decoder.handleConflictingOneOf()
            if case .upsample(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._layer = .upsample(v)}
        case 220:
          var v: CoreML_Specification_UnaryFunctionLayerParams?
          if let current = _storage._layer {
            try decoder.handleConflictingOneOf()
            if case .unary(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._layer = .unary(v)}
        case 230:
          var v: CoreML_Specification_AddLayerParams?
          if let current = _storage._layer {
            try decoder.handleConflictingOneOf()
            if case .add(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._layer = .add(v)}
        case 231:
          var v: CoreML_Specification_MultiplyLayerParams?
          if let current = _storage._layer {
            try decoder.handleConflictingOneOf()
            if case .multiply(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._layer = .multiply(v)}
        case 240:
          var v: CoreML_Specification_AverageLayerParams?
          if let current = _storage._layer {
            try decoder.handleConflictingOneOf()
            if case .average(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._layer = .average(v)}
        case 245:
          var v: CoreML_Specification_ScaleLayerParams?
          if let current = _storage._layer {
            try decoder.handleConflictingOneOf()
            if case .scale(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._layer = .scale(v)}
        case 250:
          var v: CoreML_Specification_BiasLayerParams?
          if let current = _storage._layer {
            try decoder.handleConflictingOneOf()
            if case .bias(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._layer = .bias(v)}
        case 260:
          var v: CoreML_Specification_MaxLayerParams?
          if let current = _storage._layer {
            try decoder.handleConflictingOneOf()
            if case .max(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._layer = .max(v)}
        case 261:
          var v: CoreML_Specification_MinLayerParams?
          if let current = _storage._layer {
            try decoder.handleConflictingOneOf()
            if case .min(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._layer = .min(v)}
        case 270:
          var v: CoreML_Specification_DotProductLayerParams?
          if let current = _storage._layer {
            try decoder.handleConflictingOneOf()
            if case .dot(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._layer = .dot(v)}
        case 280:
          var v: CoreML_Specification_ReduceLayerParams?
          if let current = _storage._layer {
            try decoder.handleConflictingOneOf()
            if case .reduce(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._layer = .reduce(v)}
        case 290:
          var v: CoreML_Specification_LoadConstantLayerParams?
          if let current = _storage._layer {
            try decoder.handleConflictingOneOf()
            if case .loadConstant(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._layer = .loadConstant(v)}
        case 300:
          var v: CoreML_Specification_ReshapeLayerParams?
          if let current = _storage._layer {
            try decoder.handleConflictingOneOf()
            if case .reshape(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._layer = .reshape(v)}
        case 301:
          var v: CoreML_Specification_FlattenLayerParams?
          if let current = _storage._layer {
            try decoder.handleConflictingOneOf()
            if case .flatten(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._layer = .flatten(v)}
        case 310:
          var v: CoreML_Specification_PermuteLayerParams?
          if let current = _storage._layer {
            try decoder.handleConflictingOneOf()
            if case .permute(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._layer = .permute(v)}
        case 320:
          var v: CoreML_Specification_ConcatLayerParams?
          if let current = _storage._layer {
            try decoder.handleConflictingOneOf()
            if case .concat(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._layer = .concat(v)}
        case 330:
          var v: CoreML_Specification_SplitLayerParams?
          if let current = _storage._layer {
            try decoder.handleConflictingOneOf()
            if case .split(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._layer = .split(v)}
        case 340:
          var v: CoreML_Specification_SequenceRepeatLayerParams?
          if let current = _storage._layer {
            try decoder.handleConflictingOneOf()
            if case .sequenceRepeat(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._layer = .sequenceRepeat(v)}
        case 345:
          var v: CoreML_Specification_ReorganizeDataLayerParams?
          if let current = _storage._layer {
            try decoder.handleConflictingOneOf()
            if case .reorganizeData(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._layer = .reorganizeData(v)}
        case 350:
          var v: CoreML_Specification_SliceLayerParams?
          if let current = _storage._layer {
            try decoder.handleConflictingOneOf()
            if case .slice(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._layer = .slice(v)}
        case 400:
          var v: CoreML_Specification_SimpleRecurrentLayerParams?
          if let current = _storage._layer {
            try decoder.handleConflictingOneOf()
            if case .simpleRecurrent(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._layer = .simpleRecurrent(v)}
        case 410:
          var v: CoreML_Specification_GRULayerParams?
          if let current = _storage._layer {
            try decoder.handleConflictingOneOf()
            if case .gru(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._layer = .gru(v)}
        case 420:
          var v: CoreML_Specification_UniDirectionalLSTMLayerParams?
          if let current = _storage._layer {
            try decoder.handleConflictingOneOf()
            if case .uniDirectionalLstm(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._layer = .uniDirectionalLstm(v)}
        case 430:
          var v: CoreML_Specification_BiDirectionalLSTMLayerParams?
          if let current = _storage._layer {
            try decoder.handleConflictingOneOf()
            if case .biDirectionalLstm(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._layer = .biDirectionalLstm(v)}
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if !_storage._input.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._input, fieldNumber: 2)
      }
      if !_storage._output.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._output, fieldNumber: 3)
      }
      switch _storage._layer {
      case .convolution(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 100)
      case .pooling(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 120)
      case .activation(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 130)
      case .innerProduct(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 140)
      case .embedding(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 150)
      case .batchnorm(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 160)
      case .mvn(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 165)
      case .l2Normalize(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 170)
      case .softmax(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 175)
      case .lrn(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 180)
      case .crop(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 190)
      case .padding(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 200)
      case .upsample(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 210)
      case .unary(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 220)
      case .add(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 230)
      case .multiply(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 231)
      case .average(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 240)
      case .scale(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 245)
      case .bias(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 250)
      case .max(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 260)
      case .min(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 261)
      case .dot(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 270)
      case .reduce(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 280)
      case .loadConstant(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 290)
      case .reshape(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 300)
      case .flatten(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 301)
      case .permute(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 310)
      case .concat(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 320)
      case .split(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 330)
      case .sequenceRepeat(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 340)
      case .reorganizeData(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 345)
      case .slice(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 350)
      case .simpleRecurrent(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 400)
      case .gru(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 410)
      case .uniDirectionalLstm(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 420)
      case .biDirectionalLstm(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 430)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// Specifies the amount of spatial border to be either padded or cropped.
///
/// For padding:
/// ::
///     H_out = borderAmounts[0].startEdgeSize + H_in + borderAmounts[0].endEdgeSize
///     W_out = borderAmounts[1].startEdgeSize + W_in + borderAmounts[1].endEdgeSize
///
///     topPaddingAmount == Height startEdgeSize
///     bottomPaddingAmount == Height endEdgeSize
///     leftPaddingAmount == Width startEdgeSize
///     rightPaddingAmount == Width endEdgeSize
///
/// For cropping:
/// ::
///     H_out = (-borderAmounts[0].startEdgeSize) + H_in + (-borderAmounts[0].endEdgeSize)
///     W_out = (-borderAmounts[1].startEdgeSize) + W_in + (-borderAmounts[1].endEdgeSize)
///
///     topCropAmount == Height startEdgeSize
///     bottomCropAmount == Height endEdgeSize
///     leftCropAmount == Width startEdgeSize
///     rightCropAmount == Width endEdgeSize
public struct CoreML_Specification_BorderAmounts: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".BorderAmounts"

  ///*
  /// The border amounts.
  /// This must be length 2 in the order ``[H, W]``.
  public var borderAmounts: [CoreML_Specification_BorderAmounts.EdgeSizes] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct EdgeSizes: SwiftProtobuf.Message {
    public static let protoMessageName: String = CoreML_Specification_BorderAmounts.protoMessageName + ".EdgeSizes"

    ///*
    /// The amount to be padded or cropped from the beginning.
    public var startEdgeSize: UInt64 = 0

    ///*
    /// The amount to be padded or cropped from the end.
    public var endEdgeSize: UInt64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    /// Used by the decoding initializers in the SwiftProtobuf library, not generally
    /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
    /// initializers are defined in the SwiftProtobuf library. See the Message and
    /// Message+*Additions` files.
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt64Field(value: &self.startEdgeSize)
        case 2: try decoder.decodeSingularUInt64Field(value: &self.endEdgeSize)
        default: break
        }
      }
    }

    /// Used by the encoding methods of the SwiftProtobuf library, not generally
    /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
    /// other serializer methods are defined in the SwiftProtobuf library. See the
    /// `Message` and `Message+*Additions` files.
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      if self.startEdgeSize != 0 {
        try visitor.visitSingularUInt64Field(value: self.startEdgeSize, fieldNumber: 1)
      }
      if self.endEdgeSize != 0 {
        try visitor.visitSingularUInt64Field(value: self.endEdgeSize, fieldNumber: 2)
      }
      try unknownFields.traverse(visitor: &visitor)
    }
  }

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 10: try decoder.decodeRepeatedMessageField(value: &self.borderAmounts)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.borderAmounts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.borderAmounts, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// Specifies the type of padding to be used with Convolution/Deconvolution and Pooling layers. 
/// After padding, input spatial shape: ``[H_in, W_in]``, gets modified to the
/// output spatial shape ``[H_out, W_out]``.  
/// ::
/// 		topPaddingAmount == Height startEdgeSize == borderAmounts[0].startEdgeSize
/// 		bottomPaddingAmount == Height endEdgeSize == borderAmounts[0].endEdgeSize
/// 		leftPaddingAmount == Width startEdgeSize == borderAmounts[1].startEdgeSize
/// 		rightPaddingAmount == Width endEdgeSize == borderAmounts[1].endEdgeSize
/// 
/// With Convolution or Pooling:  
/// ::
///    H_out = int_division_round_down((H_in + topPaddingAmount + bottomPaddingAmount - KernelSize[0]),stride[0]) + 1  
///
/// which is same as:   
/// ::
///    H_out = int_division_round_up((H_in + topPaddingAmount + bottomPaddingAmount - KernelSize[0] + 1),stride[0])  
///  
/// With Deconvolution: 
/// ::
///    H_out = (H_in-1) * stride[0] + kernelSize[0] - (topPaddingAmount + bottomPaddingAmount)
///
///  
/// The equivalent expressions hold true for ``W_out`` as well.
///
///
/// By default, the values of ``paddingAmounts`` are set to ``0``,
/// which results in a "true" valid padding.
/// If non-zero values are provided for ``paddingAmounts``,
/// "valid" convolution/pooling is performed within the spatially expanded input.
public struct CoreML_Specification_ValidPadding: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".ValidPadding"

  public var paddingAmounts: CoreML_Specification_BorderAmounts {
    get {return _storage._paddingAmounts ?? CoreML_Specification_BorderAmounts()}
    set {_uniqueStorage()._paddingAmounts = newValue}
  }
  /// Returns true if `paddingAmounts` has been explicitly set.
  public var hasPaddingAmounts: Bool {return _storage._paddingAmounts != nil}
  /// Clears the value of `paddingAmounts`. Subsequent reads from it will return its default value.
  public mutating func clearPaddingAmounts() {_storage._paddingAmounts = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._paddingAmounts)
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._paddingAmounts {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// Specifies the type of padding to be used with Convolution/Deconvolution and pooling layers. 
/// After padding, input spatial shape: ``[H_in, W_in]``, gets modified to the
/// output spatial shape ``[H_out, W_out]``.  
/// With Convolution or pooling:  
/// ::
/// 		H_out = int_division_round_up(H_in,stride[0])  
/// 		W_out = int_division_round_up(W_in,stride[1])  
/// 		
/// This is achieved by using the following padding amounts:
/// ::
///     totalPaddingHeight = max(0,(H_out-1) * stride[0] + KernelSize[0] - Hin)
///     totalPaddingWidth = max(0,(W_out-1) * stride[1] + KernelSize[1] - Win)
///
/// There are two modes of asymmetry: 
/// ``BOTTOM_RIGHT_HEAVY``, and ``TOP_LEFT_HEAVY``.
///
/// If the mode is ``BOTTOM_RIGHT_HEAVY``:
/// ::
///     topPaddingAmount = floor(totalPaddingHeight / 2)
///     bottomPaddingAmount = totalPaddingHeight - topPaddingAmount
///     leftPaddingAmount = floor(totalPaddingWidth / 2)
///     rightPaddingAmount = totalPaddingWidth - leftPaddingAmount
///
/// If the mode is ``TOP_LEFT_HEAVY``:
/// ::
///     bottomPaddingAmount = floor(totalPaddingHeight / 2)
///     topPaddingAmount = totalPaddingHeight - bottomPaddingAmount
///     rightPaddingAmount = floor(totalPaddingWidth / 2)
///     leftPaddingAmount = totalPaddingWidth - rightPaddingAmount
///
///
/// With Deconvolution: 
/// ::
///    H_out = H_in * stride[0]   
///    W_out = W_in * stride[1]   
public struct CoreML_Specification_SamePadding: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".SamePadding"

  public var asymmetryMode: CoreML_Specification_SamePadding.SamePaddingMode = .bottomRightHeavy

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum SamePaddingMode: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case bottomRightHeavy // = 0
    case topLeftHeavy // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .bottomRightHeavy
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .bottomRightHeavy
      case 1: self = .topLeftHeavy
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .bottomRightHeavy: return 0
      case .topLeftHeavy: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.asymmetryMode)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.asymmetryMode != .bottomRightHeavy {
      try visitor.visitSingularEnumField(value: self.asymmetryMode, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// Weights for layer parameters.
/// Weights are stored as repeated floating point numbers
/// using row-major ordering
/// and can represent 1-, 2-, 3-, or 4-dimensional data.
public struct CoreML_Specification_WeightParams: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".WeightParams"

  ///*
  /// Values specified in single / float / FP32 precision.
  public var floatValue: [Float] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedFloatField(value: &self.floatValue)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.floatValue.isEmpty {
      try visitor.visitPackedFloatField(value: self.floatValue, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// A layer that performs spatial convolution or deconvolution.
/// ::
/// 		y = ConvolutionLayer(x)
///
/// Requires 1 input and produces 1 output.
///
/// Input 
///  A blob with shape ``[inputChannels,inputHeight,inputWidth]`` or ``[C_in, H_in, W_in]``.      
/// 
/// Output 
///  A blob with shape ``[outputChannels,outputHeight,outputWidth]`` or  ``[C_out, H_out, W_out]``.
///
///
/// If ``dilationFactor`` is not 1, effective kernel size is
/// modified as follows: 
/// ::
/// 		KernelSize[0] <-- (kernelSize[0]-1) * dilationFactor[0] + 1  
///		KernelSize[1] <-- (kernelSize[1]-1) * dilationFactor[1] + 1 
///
/// Type of padding can be ``valid`` or ``same``. Output spatial dimensions depend on the 
/// the type of padding. For details, refer to the descriptions of the messages "ValidPadding"
/// and "SamePadding". Padded values are all zeros.
///
/// For Deconvolution, ``ConvolutionPaddingType`` (``valid`` or ``same``) is ignored when ``outputShape`` is set. 
public struct CoreML_Specification_ConvolutionLayerParams: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".ConvolutionLayerParams"

  ///*
  /// The number of kernels.
  /// Same as ``C_out`` used in the layer description.
  public var outputChannels: UInt64 {
    get {return _storage._outputChannels}
    set {_uniqueStorage()._outputChannels = newValue}
  }

  ///*
  /// Channel dimension of the kernels.
  /// Must be equal to ``inputChannels / nGroups``, if isDeconvolution == False
  /// Must be equal to ``inputChannels``, if isDeconvolution == True
  public var kernelChannels: UInt64 {
    get {return _storage._kernelChannels}
    set {_uniqueStorage()._kernelChannels = newValue}
  }

  ///*
  /// Group convolution, i.e. weight reuse along channel axis.
  /// Input and kernels are divided into g groups
  /// and convolution / deconvoltuion is applied within the groups independently. 
  /// If not set or 0, it is set to the default value 1.
  public var nGroups: UInt64 {
    get {return _storage._nGroups}
    set {_uniqueStorage()._nGroups = newValue}
  }

  ///*
  /// Must be length 2 in the order ``[H, W]``.
  /// If not set, default value ``[3, 3]`` is used.
  public var kernelSize: [UInt64] {
    get {return _storage._kernelSize}
    set {_uniqueStorage()._kernelSize = newValue}
  }

  ///*
  /// Must be length 2 in the order ``[H, W]``.
  /// If not set, default value ``[1, 1]`` is used.
  public var stride: [UInt64] {
    get {return _storage._stride}
    set {_uniqueStorage()._stride = newValue}
  }

  ///*
  /// Must be length 2 in order ``[H, W]``.
  /// If not set, default value ``[1, 1]`` is used.
  /// It is ignored if ``isDeconvolution == true``.
  public var dilationFactor: [UInt64] {
    get {return _storage._dilationFactor}
    set {_uniqueStorage()._dilationFactor = newValue}
  }

  ///*
  /// The type of padding.
  public var convolutionPaddingType: OneOf_ConvolutionPaddingType? {
    get {return _storage._convolutionPaddingType}
    set {_uniqueStorage()._convolutionPaddingType = newValue}
  }

  public var valid: CoreML_Specification_ValidPadding {
    get {
      if case .valid(let v)? = _storage._convolutionPaddingType {return v}
      return CoreML_Specification_ValidPadding()
    }
    set {_uniqueStorage()._convolutionPaddingType = .valid(newValue)}
  }

  public var same: CoreML_Specification_SamePadding {
    get {
      if case .same(let v)? = _storage._convolutionPaddingType {return v}
      return CoreML_Specification_SamePadding()
    }
    set {_uniqueStorage()._convolutionPaddingType = .same(newValue)}
  }

  ///*
  /// Flag to specify whether it is a deconvolution layer.
  public var isDeconvolution: Bool {
    get {return _storage._isDeconvolution}
    set {_uniqueStorage()._isDeconvolution = newValue}
  }

  ///*
  /// Flag to specify whether a bias is to be added or not.
  public var hasBias_p: Bool {
    get {return _storage._hasBias_p}
    set {_uniqueStorage()._hasBias_p = newValue}
  }

  ///*
  /// Weights associated with this layer.
  /// If convolution (``isDeconvolution == false``), weights have the shape
  /// ``[outputChannels, kernelChannels, kernelHeight, kernelWidth]``, where kernelChannels == inputChannels / nGroups
  /// If deconvolution (``isDeconvolution == true``) weights have the shape
  /// ``[kernelChannels, outputChannels / nGroups, kernelHeight, kernelWidth]``, where kernelChannels == inputChannels
  public var weights: CoreML_Specification_WeightParams {
    get {return _storage._weights ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._weights = newValue}
  }
  /// Returns true if `weights` has been explicitly set.
  public var hasWeights: Bool {return _storage._weights != nil}
  /// Clears the value of `weights`. Subsequent reads from it will return its default value.
  public mutating func clearWeights() {_storage._weights = nil}

  //// Must be of size [outputChannels].
  public var bias: CoreML_Specification_WeightParams {
    get {return _storage._bias ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._bias = newValue}
  }
  /// Returns true if `bias` has been explicitly set.
  public var hasBias: Bool {return _storage._bias != nil}
  /// Clears the value of `bias`. Subsequent reads from it will return its default value.
  public mutating func clearBias() {_storage._bias = nil}

  ///*
  /// The output shape, which has length 2 ``[H_out, W_out]``.
  /// This is used only for deconvolution (``isDeconvolution == true``).
  /// If not set, the deconvolution output shape is calculated
  /// based on ``ConvolutionPaddingType``.
  public var outputShape: [UInt64] {
    get {return _storage._outputShape}
    set {_uniqueStorage()._outputShape = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  ///*
  /// The type of padding.
  public enum OneOf_ConvolutionPaddingType: Equatable {
    case valid(CoreML_Specification_ValidPadding)
    case same(CoreML_Specification_SamePadding)

    public static func ==(lhs: CoreML_Specification_ConvolutionLayerParams.OneOf_ConvolutionPaddingType, rhs: CoreML_Specification_ConvolutionLayerParams.OneOf_ConvolutionPaddingType) -> Bool {
      switch (lhs, rhs) {
      case (.valid(let l), .valid(let r)): return l == r
      case (.same(let l), .same(let r)): return l == r
      default: return false
      }
    }
  }

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt64Field(value: &_storage._outputChannels)
        case 2: try decoder.decodeSingularUInt64Field(value: &_storage._kernelChannels)
        case 10: try decoder.decodeSingularUInt64Field(value: &_storage._nGroups)
        case 20: try decoder.decodeRepeatedUInt64Field(value: &_storage._kernelSize)
        case 30: try decoder.decodeRepeatedUInt64Field(value: &_storage._stride)
        case 40: try decoder.decodeRepeatedUInt64Field(value: &_storage._dilationFactor)
        case 50:
          var v: CoreML_Specification_ValidPadding?
          if let current = _storage._convolutionPaddingType {
            try decoder.handleConflictingOneOf()
            if case .valid(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._convolutionPaddingType = .valid(v)}
        case 51:
          var v: CoreML_Specification_SamePadding?
          if let current = _storage._convolutionPaddingType {
            try decoder.handleConflictingOneOf()
            if case .same(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._convolutionPaddingType = .same(v)}
        case 60: try decoder.decodeSingularBoolField(value: &_storage._isDeconvolution)
        case 70: try decoder.decodeSingularBoolField(value: &_storage._hasBias_p)
        case 90: try decoder.decodeSingularMessageField(value: &_storage._weights)
        case 91: try decoder.decodeSingularMessageField(value: &_storage._bias)
        case 100: try decoder.decodeRepeatedUInt64Field(value: &_storage._outputShape)
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._outputChannels != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._outputChannels, fieldNumber: 1)
      }
      if _storage._kernelChannels != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._kernelChannels, fieldNumber: 2)
      }
      if _storage._nGroups != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._nGroups, fieldNumber: 10)
      }
      if !_storage._kernelSize.isEmpty {
        try visitor.visitPackedUInt64Field(value: _storage._kernelSize, fieldNumber: 20)
      }
      if !_storage._stride.isEmpty {
        try visitor.visitPackedUInt64Field(value: _storage._stride, fieldNumber: 30)
      }
      if !_storage._dilationFactor.isEmpty {
        try visitor.visitPackedUInt64Field(value: _storage._dilationFactor, fieldNumber: 40)
      }
      switch _storage._convolutionPaddingType {
      case .valid(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 50)
      case .same(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 51)
      case nil: break
      }
      if _storage._isDeconvolution != false {
        try visitor.visitSingularBoolField(value: _storage._isDeconvolution, fieldNumber: 60)
      }
      if _storage._hasBias_p != false {
        try visitor.visitSingularBoolField(value: _storage._hasBias_p, fieldNumber: 70)
      }
      if let v = _storage._weights {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 90)
      }
      if let v = _storage._bias {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 91)
      }
      if !_storage._outputShape.isEmpty {
        try visitor.visitPackedUInt64Field(value: _storage._outputShape, fieldNumber: 100)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// A layer that performs a matrix vector product.
/// This is equivalent to a fully-connected, or dense layer.
/// ::
///		y = InnerProductLayer(x)
///
/// Requires 1 input and produces 1 output.
///
/// Input 
/// 	A blob with shape ``[C_in]`` or ``[C_in, 1, 1]``, where ``C_in`` is equal to ``inputChannels``.
///
/// Output 
///  A blob with shape ``[C_out]``, where ``C_out`` is equal to ``outputChannels``.
public struct CoreML_Specification_InnerProductLayerParams: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".InnerProductLayerParams"

  //// Input size: C_in.
  public var inputChannels: UInt64 {
    get {return _storage._inputChannels}
    set {_uniqueStorage()._inputChannels = newValue}
  }

  //// Output size: C_out.
  public var outputChannels: UInt64 {
    get {return _storage._outputChannels}
    set {_uniqueStorage()._outputChannels = newValue}
  }

  //// Whether a bias is added or not.
  public var hasBias_p: Bool {
    get {return _storage._hasBias_p}
    set {_uniqueStorage()._hasBias_p = newValue}
  }

  //// Weight matrix [C_out, C_in].
  public var weights: CoreML_Specification_WeightParams {
    get {return _storage._weights ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._weights = newValue}
  }
  /// Returns true if `weights` has been explicitly set.
  public var hasWeights: Bool {return _storage._weights != nil}
  /// Clears the value of `weights`. Subsequent reads from it will return its default value.
  public mutating func clearWeights() {_storage._weights = nil}

  //// Bias vector [C_out].
  public var bias: CoreML_Specification_WeightParams {
    get {return _storage._bias ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._bias = newValue}
  }
  /// Returns true if `bias` has been explicitly set.
  public var hasBias: Bool {return _storage._bias != nil}
  /// Clears the value of `bias`. Subsequent reads from it will return its default value.
  public mutating func clearBias() {_storage._bias = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt64Field(value: &_storage._inputChannels)
        case 2: try decoder.decodeSingularUInt64Field(value: &_storage._outputChannels)
        case 10: try decoder.decodeSingularBoolField(value: &_storage._hasBias_p)
        case 20: try decoder.decodeSingularMessageField(value: &_storage._weights)
        case 21: try decoder.decodeSingularMessageField(value: &_storage._bias)
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._inputChannels != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._inputChannels, fieldNumber: 1)
      }
      if _storage._outputChannels != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._outputChannels, fieldNumber: 2)
      }
      if _storage._hasBias_p != false {
        try visitor.visitSingularBoolField(value: _storage._hasBias_p, fieldNumber: 10)
      }
      if let v = _storage._weights {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      }
      if let v = _storage._bias {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// A layer that performs a matrix lookup and optionally adds a bias.
/// ::
/// 		y = EmbeddingLayer(x)
/// 
/// Requires 1 input and produces 1 output.
///
/// Input
///	   A sequence of integers with shape ``[1]`` or ``[1, 1, 1]``, (equivalent to ``[Seq_length, 1, 1, 1]``).
///	   Input values must be in the range ``[0, inputDim - 1]``.
///
/// Output
///     A sequence of 1-dimensional features of size ``outputChannels``
///     (equivalent to ``[Seq_length, outputChannels, 1, 1]``).
public struct CoreML_Specification_EmbeddingLayerParams: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".EmbeddingLayerParams"

  //// Size of the input dictionary.
  public var inputDim: UInt64 {
    get {return _storage._inputDim}
    set {_uniqueStorage()._inputDim = newValue}
  }

  //// Size of the output vectors.
  public var outputChannels: UInt64 {
    get {return _storage._outputChannels}
    set {_uniqueStorage()._outputChannels = newValue}
  }

  //// Whether a bias is added or not.
  public var hasBias_p: Bool {
    get {return _storage._hasBias_p}
    set {_uniqueStorage()._hasBias_p = newValue}
  }

  //// 2-D weights of dimensions [outputChannels, inputDim].
  public var weights: CoreML_Specification_WeightParams {
    get {return _storage._weights ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._weights = newValue}
  }
  /// Returns true if `weights` has been explicitly set.
  public var hasWeights: Bool {return _storage._weights != nil}
  /// Clears the value of `weights`. Subsequent reads from it will return its default value.
  public mutating func clearWeights() {_storage._weights = nil}

  //// Bias of size [outputChannels].
  public var bias: CoreML_Specification_WeightParams {
    get {return _storage._bias ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._bias = newValue}
  }
  /// Returns true if `bias` has been explicitly set.
  public var hasBias: Bool {return _storage._bias != nil}
  /// Clears the value of `bias`. Subsequent reads from it will return its default value.
  public mutating func clearBias() {_storage._bias = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt64Field(value: &_storage._inputDim)
        case 2: try decoder.decodeSingularUInt64Field(value: &_storage._outputChannels)
        case 10: try decoder.decodeSingularBoolField(value: &_storage._hasBias_p)
        case 20: try decoder.decodeSingularMessageField(value: &_storage._weights)
        case 21: try decoder.decodeSingularMessageField(value: &_storage._bias)
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._inputDim != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._inputDim, fieldNumber: 1)
      }
      if _storage._outputChannels != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._outputChannels, fieldNumber: 2)
      }
      if _storage._hasBias_p != false {
        try visitor.visitSingularBoolField(value: _storage._hasBias_p, fieldNumber: 10)
      }
      if let v = _storage._weights {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      }
      if let v = _storage._bias {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// A layer that performs batch normalization,
/// which is performed along the channel axis,
/// and repeated along the other axes, if present.
/// ::
///		y = BatchnormLayer(x)
/// Requires 1 input and produces 1 output.
///
/// This operation is described by the following formula:
///
/// .. math::
///     y_i = \gamma_i \dfrac{ (x_i - \mu_i)}{\sqrt{\sigma_i^2 + \epsilon}} + \beta_i \;,\;i=1,....,C
///
/// Input
///     A blob with shape ``[C]`` or ``[C, H, W]``.
///
/// Output
///     A blob with the same shape as the input.
public struct CoreML_Specification_BatchnormLayerParams: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".BatchnormLayerParams"

  //// Size of the channel dimension in the input.
  public var channels: UInt64 {
    get {return _storage._channels}
    set {_uniqueStorage()._channels = newValue}
  }

  ///*
  /// If ``computeMeanVar == true``,
  /// the mean and variance are calculated from either
  /// the single input instance, if ``instanceNormalization == true``,
  /// or the whole batch, if ``instanceNormalization = false``.
  /// and the values provided in parameters "mean" and "variance" are ignored. 
  public var computeMeanVar: Bool {
    get {return _storage._computeMeanVar}
    set {_uniqueStorage()._computeMeanVar = newValue}
  }

  public var instanceNormalization: Bool {
    get {return _storage._instanceNormalization}
    set {_uniqueStorage()._instanceNormalization = newValue}
  }

  ///*
  /// A small constant to avoid division by 0 while normalizing by variance.
  /// Defaults to ``1e-5`` if not set or set to ``0``.
  public var epsilon: Float {
    get {return _storage._epsilon}
    set {_uniqueStorage()._epsilon = newValue}
  }

  //// Parameter of length [channels]
  public var gamma: CoreML_Specification_WeightParams {
    get {return _storage._gamma ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._gamma = newValue}
  }
  /// Returns true if `gamma` has been explicitly set.
  public var hasGamma: Bool {return _storage._gamma != nil}
  /// Clears the value of `gamma`. Subsequent reads from it will return its default value.
  public mutating func clearGamma() {_storage._gamma = nil}

  //// Parameter of length [channels]
  public var beta: CoreML_Specification_WeightParams {
    get {return _storage._beta ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._beta = newValue}
  }
  /// Returns true if `beta` has been explicitly set.
  public var hasBeta: Bool {return _storage._beta != nil}
  /// Clears the value of `beta`. Subsequent reads from it will return its default value.
  public mutating func clearBeta() {_storage._beta = nil}

  //// Parameter of length [channels]
  public var mean: CoreML_Specification_WeightParams {
    get {return _storage._mean ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._mean = newValue}
  }
  /// Returns true if `mean` has been explicitly set.
  public var hasMean: Bool {return _storage._mean != nil}
  /// Clears the value of `mean`. Subsequent reads from it will return its default value.
  public mutating func clearMean() {_storage._mean = nil}

  //// Parameter of length [channels]
  public var variance: CoreML_Specification_WeightParams {
    get {return _storage._variance ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._variance = newValue}
  }
  /// Returns true if `variance` has been explicitly set.
  public var hasVariance: Bool {return _storage._variance != nil}
  /// Clears the value of `variance`. Subsequent reads from it will return its default value.
  public mutating func clearVariance() {_storage._variance = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt64Field(value: &_storage._channels)
        case 5: try decoder.decodeSingularBoolField(value: &_storage._computeMeanVar)
        case 6: try decoder.decodeSingularBoolField(value: &_storage._instanceNormalization)
        case 10: try decoder.decodeSingularFloatField(value: &_storage._epsilon)
        case 15: try decoder.decodeSingularMessageField(value: &_storage._gamma)
        case 16: try decoder.decodeSingularMessageField(value: &_storage._beta)
        case 17: try decoder.decodeSingularMessageField(value: &_storage._mean)
        case 18: try decoder.decodeSingularMessageField(value: &_storage._variance)
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._channels != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._channels, fieldNumber: 1)
      }
      if _storage._computeMeanVar != false {
        try visitor.visitSingularBoolField(value: _storage._computeMeanVar, fieldNumber: 5)
      }
      if _storage._instanceNormalization != false {
        try visitor.visitSingularBoolField(value: _storage._instanceNormalization, fieldNumber: 6)
      }
      if _storage._epsilon != 0 {
        try visitor.visitSingularFloatField(value: _storage._epsilon, fieldNumber: 10)
      }
      if let v = _storage._gamma {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
      if let v = _storage._beta {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      }
      if let v = _storage._mean {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }
      if let v = _storage._variance {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// A spatial pooling layer.
/// :: 
/// 		y = PoolingLayer(x)
/// Requires 1 input and produces 1 output.
///
/// Input
///     A blob with shape ``[C, H_in, W_in]``.
/// Output
///     A blob with shape ``[C, H_out, W_out]``.
///
/// Padding options are similar to ``ConvolutionLayerParams``
/// with the additional option of ``ValidCompletePadding`` (``includeLastPixel``),
/// which ensures that the last application of the kernel
/// always includes the last pixel of the input image, if there is padding. 
/// ::
///     H_out = int_division_round_up((H_in + 2 * paddingAmounts[0] - kernelSize[0]),Stride[0]) + 1)
///     if (paddingAmounts[0] > 0 or paddingAmounts[1] > 0)
///          if ((H_out - 1) * Stride >= H_in + paddingAmounts[0]) {
///              H_out = H_out - 1
///          }
///     }
///
/// The equivalent expressions hold true for ``W_out`` as well.
/// Only symmetric padding is supported with this option.
public struct CoreML_Specification_PoolingLayerParams: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".PoolingLayerParams"

  //// Type of pooling operation.
  public var type: CoreML_Specification_PoolingLayerParams.PoolingType {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  ///*
  /// Must be length 2 in the order ``[H, W]``.
  /// If not set, default value ``[3, 3]`` is used.
  public var kernelSize: [UInt64] {
    get {return _storage._kernelSize}
    set {_uniqueStorage()._kernelSize = newValue}
  }

  ///*
  /// Must be length 2 in the order ``[H, W]``.
  /// If not set, default value ``[1, 1]`` is used.
  public var stride: [UInt64] {
    get {return _storage._stride}
    set {_uniqueStorage()._stride = newValue}
  }

  public var poolingPaddingType: OneOf_PoolingPaddingType? {
    get {return _storage._poolingPaddingType}
    set {_uniqueStorage()._poolingPaddingType = newValue}
  }

  public var valid: CoreML_Specification_ValidPadding {
    get {
      if case .valid(let v)? = _storage._poolingPaddingType {return v}
      return CoreML_Specification_ValidPadding()
    }
    set {_uniqueStorage()._poolingPaddingType = .valid(newValue)}
  }

  public var same: CoreML_Specification_SamePadding {
    get {
      if case .same(let v)? = _storage._poolingPaddingType {return v}
      return CoreML_Specification_SamePadding()
    }
    set {_uniqueStorage()._poolingPaddingType = .same(newValue)}
  }

  public var includeLastPixel: CoreML_Specification_PoolingLayerParams.ValidCompletePadding {
    get {
      if case .includeLastPixel(let v)? = _storage._poolingPaddingType {return v}
      return CoreML_Specification_PoolingLayerParams.ValidCompletePadding()
    }
    set {_uniqueStorage()._poolingPaddingType = .includeLastPixel(newValue)}
  }

  ///*
  /// If true, padded values are excluded from the count (denominator)
  /// when computing average pooling.
  public var avgPoolExcludePadding: Bool {
    get {return _storage._avgPoolExcludePadding}
    set {_uniqueStorage()._avgPoolExcludePadding = newValue}
  }

  ///*
  /// If true, global pooling is performed.
  /// Kernel size is inferred from the input data spatial dimensions.
  public var globalPooling: Bool {
    get {return _storage._globalPooling}
    set {_uniqueStorage()._globalPooling = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_PoolingPaddingType: Equatable {
    case valid(CoreML_Specification_ValidPadding)
    case same(CoreML_Specification_SamePadding)
    case includeLastPixel(CoreML_Specification_PoolingLayerParams.ValidCompletePadding)

    public static func ==(lhs: CoreML_Specification_PoolingLayerParams.OneOf_PoolingPaddingType, rhs: CoreML_Specification_PoolingLayerParams.OneOf_PoolingPaddingType) -> Bool {
      switch (lhs, rhs) {
      case (.valid(let l), .valid(let r)): return l == r
      case (.same(let l), .same(let r)): return l == r
      case (.includeLastPixel(let l), .includeLastPixel(let r)): return l == r
      default: return false
      }
    }
  }

  public enum PoolingType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case max // = 0
    case average // = 1
    case l2 // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .max
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .max
      case 1: self = .average
      case 2: self = .l2
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .max: return 0
      case .average: return 1
      case .l2: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public struct ValidCompletePadding: SwiftProtobuf.Message {
    public static let protoMessageName: String = CoreML_Specification_PoolingLayerParams.protoMessageName + ".ValidCompletePadding"

    ///*
    /// Must be length 2 in order ``[H, W]``.
    /// If not set, value ``[0, 0]`` is used.
    public var paddingAmounts: [UInt64] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    /// Used by the decoding initializers in the SwiftProtobuf library, not generally
    /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
    /// initializers are defined in the SwiftProtobuf library. See the Message and
    /// Message+*Additions` files.
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 10: try decoder.decodeRepeatedUInt64Field(value: &self.paddingAmounts)
        default: break
        }
      }
    }

    /// Used by the encoding methods of the SwiftProtobuf library, not generally
    /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
    /// other serializer methods are defined in the SwiftProtobuf library. See the
    /// `Message` and `Message+*Additions` files.
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      if !self.paddingAmounts.isEmpty {
        try visitor.visitPackedUInt64Field(value: self.paddingAmounts, fieldNumber: 10)
      }
      try unknownFields.traverse(visitor: &visitor)
    }
  }

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._type)
        case 10: try decoder.decodeRepeatedUInt64Field(value: &_storage._kernelSize)
        case 20: try decoder.decodeRepeatedUInt64Field(value: &_storage._stride)
        case 30:
          var v: CoreML_Specification_ValidPadding?
          if let current = _storage._poolingPaddingType {
            try decoder.handleConflictingOneOf()
            if case .valid(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._poolingPaddingType = .valid(v)}
        case 31:
          var v: CoreML_Specification_SamePadding?
          if let current = _storage._poolingPaddingType {
            try decoder.handleConflictingOneOf()
            if case .same(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._poolingPaddingType = .same(v)}
        case 32:
          var v: CoreML_Specification_PoolingLayerParams.ValidCompletePadding?
          if let current = _storage._poolingPaddingType {
            try decoder.handleConflictingOneOf()
            if case .includeLastPixel(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._poolingPaddingType = .includeLastPixel(v)}
        case 50: try decoder.decodeSingularBoolField(value: &_storage._avgPoolExcludePadding)
        case 60: try decoder.decodeSingularBoolField(value: &_storage._globalPooling)
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._type != .max {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 1)
      }
      if !_storage._kernelSize.isEmpty {
        try visitor.visitPackedUInt64Field(value: _storage._kernelSize, fieldNumber: 10)
      }
      if !_storage._stride.isEmpty {
        try visitor.visitPackedUInt64Field(value: _storage._stride, fieldNumber: 20)
      }
      switch _storage._poolingPaddingType {
      case .valid(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
      case .same(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
      case .includeLastPixel(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
      case nil: break
      }
      if _storage._avgPoolExcludePadding != false {
        try visitor.visitSingularBoolField(value: _storage._avgPoolExcludePadding, fieldNumber: 50)
      }
      if _storage._globalPooling != false {
        try visitor.visitSingularBoolField(value: _storage._globalPooling, fieldNumber: 60)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// A layer that performs padding along spatial dimensions.
/// ::
/// 		y = PaddingLayer(x)
/// Requires 1 input and produces 1 output.
///
/// Input
///     A blob with shape ``[C, H_in, W_in]``.
///
/// Output
///     A blob with shape ``[C, H_out, W_out]``.
/// Output dimensions are calculated as follows:
/// ::
///     H_out = H_in + topPaddingAmount + bottomPaddingAmount
///     W_out = W_in + leftPaddingAmount + rightPaddingAmount
///
///     topPaddingAmount == Height startEdgeSize == borderAmounts[0].startEdgeSize
///     bottomPaddingAmount == Height endEdgeSize == borderAmounts[0].endEdgeSize
///     leftPaddingAmount == Width startEdgeSize == borderAmounts[1].startEdgeSize
///     rightPaddingAmount == Width endEdgeSize == borderAmounts[1].endEdgeSize
///
/// There are three types of padding:
///
/// - ``PaddingConstant``, which fills a constant value at the border.
/// - ``PaddingReflection``, which reflects the values at the border.
/// - ``PaddingReplication``, which replicates the values at the border.
///
/// Given the following input:
/// ::
///     [1, 3, 4]  :  1   2   3   4
///                   5   6   7   8
///                   9   10  11  12
///
/// Here is the output of applying the padding
/// ``(top=2, left=2, bottom=0, right=0)``
/// with each of the supported types:
///
/// - ``PaddingConstant`` (``value = 0``):
///   ::
///       [1, 5, 6]  :  0   0   0  0   0   0
///                     0   0   0  0   0   0
///                     0   0   1  2   3   4
///                     0   0   5  6   7   8
///                     0   0   9  10  11  12
///
/// - ``PaddingReflection``:
///   ::
///       [1, 5, 6]  :  11  10  9  10  11  12
///                     7   6   5  6   7   8
///                     3   2   1  2   3   4
///                     7   6   5  6   7   8
///                     11  10  9  10  11  12
///
/// - ``PaddingReplication``:
///   ::
///       [1, 5, 6]  :  1   1   1  2   3   4
///                     1   1   1  2   3   4
///                     1   1   1  2   3   4
///                     5   5   5  6   7   8
///                     9   9   9  10  11  12
public struct CoreML_Specification_PaddingLayerParams: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".PaddingLayerParams"

  public var paddingType: OneOf_PaddingType? {
    get {return _storage._paddingType}
    set {_uniqueStorage()._paddingType = newValue}
  }

  public var constant: CoreML_Specification_PaddingLayerParams.PaddingConstant {
    get {
      if case .constant(let v)? = _storage._paddingType {return v}
      return CoreML_Specification_PaddingLayerParams.PaddingConstant()
    }
    set {_uniqueStorage()._paddingType = .constant(newValue)}
  }

  public var reflection: CoreML_Specification_PaddingLayerParams.PaddingReflection {
    get {
      if case .reflection(let v)? = _storage._paddingType {return v}
      return CoreML_Specification_PaddingLayerParams.PaddingReflection()
    }
    set {_uniqueStorage()._paddingType = .reflection(newValue)}
  }

  public var replication: CoreML_Specification_PaddingLayerParams.PaddingReplication {
    get {
      if case .replication(let v)? = _storage._paddingType {return v}
      return CoreML_Specification_PaddingLayerParams.PaddingReplication()
    }
    set {_uniqueStorage()._paddingType = .replication(newValue)}
  }

  //// Amounts to be padded to the input.
  public var paddingAmounts: CoreML_Specification_BorderAmounts {
    get {return _storage._paddingAmounts ?? CoreML_Specification_BorderAmounts()}
    set {_uniqueStorage()._paddingAmounts = newValue}
  }
  /// Returns true if `paddingAmounts` has been explicitly set.
  public var hasPaddingAmounts: Bool {return _storage._paddingAmounts != nil}
  /// Clears the value of `paddingAmounts`. Subsequent reads from it will return its default value.
  public mutating func clearPaddingAmounts() {_storage._paddingAmounts = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_PaddingType: Equatable {
    case constant(CoreML_Specification_PaddingLayerParams.PaddingConstant)
    case reflection(CoreML_Specification_PaddingLayerParams.PaddingReflection)
    case replication(CoreML_Specification_PaddingLayerParams.PaddingReplication)

    public static func ==(lhs: CoreML_Specification_PaddingLayerParams.OneOf_PaddingType, rhs: CoreML_Specification_PaddingLayerParams.OneOf_PaddingType) -> Bool {
      switch (lhs, rhs) {
      case (.constant(let l), .constant(let r)): return l == r
      case (.reflection(let l), .reflection(let r)): return l == r
      case (.replication(let l), .replication(let r)): return l == r
      default: return false
      }
    }
  }

  ///*
  /// Fill a constant value in the padded region.
  public struct PaddingConstant: SwiftProtobuf.Message {
    public static let protoMessageName: String = CoreML_Specification_PaddingLayerParams.protoMessageName + ".PaddingConstant"

    public var value: Float = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    /// Used by the decoding initializers in the SwiftProtobuf library, not generally
    /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
    /// initializers are defined in the SwiftProtobuf library. See the Message and
    /// Message+*Additions` files.
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularFloatField(value: &self.value)
        default: break
        }
      }
    }

    /// Used by the encoding methods of the SwiftProtobuf library, not generally
    /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
    /// other serializer methods are defined in the SwiftProtobuf library. See the
    /// `Message` and `Message+*Additions` files.
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      if self.value != 0 {
        try visitor.visitSingularFloatField(value: self.value, fieldNumber: 1)
      }
      try unknownFields.traverse(visitor: &visitor)
    }
  }

  ///*
  /// Reflect the values at the border for padding.
  public struct PaddingReflection: SwiftProtobuf.Message {
    public static let protoMessageName: String = CoreML_Specification_PaddingLayerParams.protoMessageName + ".PaddingReflection"

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    /// Used by the decoding initializers in the SwiftProtobuf library, not generally
    /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
    /// initializers are defined in the SwiftProtobuf library. See the Message and
    /// Message+*Additions` files.
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      while let _ = try decoder.nextFieldNumber() {
      }
    }

    /// Used by the encoding methods of the SwiftProtobuf library, not generally
    /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
    /// other serializer methods are defined in the SwiftProtobuf library. See the
    /// `Message` and `Message+*Additions` files.
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      try unknownFields.traverse(visitor: &visitor)
    }
  }

  ///*
  /// Replicate the values at the border for padding.
  public struct PaddingReplication: SwiftProtobuf.Message {
    public static let protoMessageName: String = CoreML_Specification_PaddingLayerParams.protoMessageName + ".PaddingReplication"

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    /// Used by the decoding initializers in the SwiftProtobuf library, not generally
    /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
    /// initializers are defined in the SwiftProtobuf library. See the Message and
    /// Message+*Additions` files.
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      while let _ = try decoder.nextFieldNumber() {
      }
    }

    /// Used by the encoding methods of the SwiftProtobuf library, not generally
    /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
    /// other serializer methods are defined in the SwiftProtobuf library. See the
    /// `Message` and `Message+*Additions` files.
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      try unknownFields.traverse(visitor: &visitor)
    }
  }

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: CoreML_Specification_PaddingLayerParams.PaddingConstant?
          if let current = _storage._paddingType {
            try decoder.handleConflictingOneOf()
            if case .constant(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._paddingType = .constant(v)}
        case 2:
          var v: CoreML_Specification_PaddingLayerParams.PaddingReflection?
          if let current = _storage._paddingType {
            try decoder.handleConflictingOneOf()
            if case .reflection(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._paddingType = .reflection(v)}
        case 3:
          var v: CoreML_Specification_PaddingLayerParams.PaddingReplication?
          if let current = _storage._paddingType {
            try decoder.handleConflictingOneOf()
            if case .replication(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._paddingType = .replication(v)}
        case 10: try decoder.decodeSingularMessageField(value: &_storage._paddingAmounts)
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._paddingType {
      case .constant(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .reflection(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .replication(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case nil: break
      }
      if let v = _storage._paddingAmounts {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// A layer that concatenates along the channel axis (default) or sequence axis.
/// ::
/// 		y = ConcatLayer(x1,x2,....)
/// Requires more than 1 input and produces 1 output.
///
/// The input and output formats are dependent on ``sequenceConcat``.
///
/// If ``sequenceConcat == true``:
///
/// Input
///     Sequences of length ``Seq_i`` of blobs with shape ``[C, H, W]``.
/// Output
///     A Sequence of length ``summation(Seq_i)`` of blobs with shape ``[C, H, W]``.
///
/// If ``sequenceConcat == false``:
///
/// Input
///     A blob with shape ``[C_i, H, W]``, where ``i = 1, 2, ...``.
/// Output
///     A blob with shape ``[summation(C_i), H, W]``.
public struct CoreML_Specification_ConcatLayerParams: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".ConcatLayerParams"

  ///*
  /// If true, concatenate along the sequence axis instead of the channel axis.
  public var sequenceConcat: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 100: try decoder.decodeSingularBoolField(value: &self.sequenceConcat)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sequenceConcat != false {
      try visitor.visitSingularBoolField(value: self.sequenceConcat, fieldNumber: 100)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// A layer that performs local response normalization (LRN).
/// ::
///  	y = LRNLayer(x)
/// Requires 1 input and produces 1 output.
///
/// Input
///     A blob with shape ``[C, H, W]``
/// Output
///     A blob with the same shape as the input.
///
/// This layer is described by the following formula:
///
/// .. math::
///     x_i \leftarrow  \dfrac{x_i}{\left ( k + \dfrac{\alpha}{C} \sum_j x_j^2 \right )^\beta}
///
/// where the summation is done over a ``(localSize, 1, 1)`` neighborhood ---
/// that is, over a window "across" channels in 1x1 spatial neighborhoods.
public struct CoreML_Specification_LRNLayerParams: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".LRNLayerParams"

  public var alpha: Float = 0

  public var beta: Float = 0

  //// Number of channels in the normalization window.
  public var localSize: UInt64 = 0

  //// Defaults to 1 if not set or 0. Must be strictly positive.
  public var k: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularFloatField(value: &self.alpha)
      case 2: try decoder.decodeSingularFloatField(value: &self.beta)
      case 3: try decoder.decodeSingularUInt64Field(value: &self.localSize)
      case 4: try decoder.decodeSingularFloatField(value: &self.k)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.alpha != 0 {
      try visitor.visitSingularFloatField(value: self.alpha, fieldNumber: 1)
    }
    if self.beta != 0 {
      try visitor.visitSingularFloatField(value: self.beta, fieldNumber: 2)
    }
    if self.localSize != 0 {
      try visitor.visitSingularUInt64Field(value: self.localSize, fieldNumber: 3)
    }
    if self.k != 0 {
      try visitor.visitSingularFloatField(value: self.k, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// Softmax Normalization Layer
///
/// A layer that performs softmax normalization.
/// Normalization is done along the channel axis.
/// ::
///  	y = SoftmaxLayer(x)
/// Requires 1 input and produces 1 output.
///
/// Input
///     A blob with shape ``[C]`` or ``[C, H, W]``.
/// Output
///     A blob with the same shape as the input.
///
/// This layer is described by the following formula:
///
/// .. math::
///     x_i \leftarrow \dfrac{e^{x_i}}{\sum_i{e^{x_i}}}
public struct CoreML_Specification_SoftmaxLayerParams: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".SoftmaxLayerParams"

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// A layer that uniformly splits across the channel dimension 
/// to produce a specified number of outputs.
/// ::
///  	(y1,y2,...yN) = SplitLayer(x), where N = nOutputs
/// Requires 1 input and produces multiple outputs.
///
/// Input
///     A blob with shape ``[C]`` or ``[C, H, W]``
/// Output
///     ``nOutputs`` blobs with shapes 
///     ``[C/nOutputs]`` or ``[C/nOutputs, H, W]``
public struct CoreML_Specification_SplitLayerParams: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".SplitLayerParams"

  //// The number of outputs.
  public var nOutputs: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.nOutputs)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.nOutputs != 0 {
      try visitor.visitSingularUInt64Field(value: self.nOutputs, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// A layer that performs elementwise addition.
/// ::
///  	y = AddLayer(x1,x2,...)
/// Requires 1 or more than 1 input and produces 1 output.
///
/// Input
///     One or more blobs with broadcastable shapes ``[1]``, ``[C]``, ``[1, H, W]``, or ``[C, H, W]``.
/// Output
///     A blob with shape equal to the input blob.
///
/// If only one input is provided, scalar addition is performed:
///
/// .. math::
///     y = x + \alpha
public struct CoreML_Specification_AddLayerParams: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".AddLayerParams"

  ///*
  /// Scalar to be added to the input.
  /// Only used if there is a single input.
  public var alpha: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularFloatField(value: &self.alpha)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.alpha != 0 {
      try visitor.visitSingularFloatField(value: self.alpha, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// A layer that performs elementwise multiplication.
/// ::
///  	y = MultiplyLayer(x1,x2,...)
/// Requires 1 or more than 1 input and produces 1 output.
///
/// Input
///     One or more blobs with broadcastable shapes ``[1]``, ``[C]``, ``[1, H, W]``, or ``[C, H, W]``.
/// Output
///     A blob with shape equal to the first input blob.
/// 
/// If only one input is provided, scalar multiplication is performed:
///
/// .. math::
///     y = \alpha x
public struct CoreML_Specification_MultiplyLayerParams: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".MultiplyLayerParams"

  ///*
  /// Scalar to be multiplied with the input. 
  /// Only used if there is a single input.
  public var alpha: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularFloatField(value: &self.alpha)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.alpha != 0 {
      try visitor.visitSingularFloatField(value: self.alpha, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// A layer that applies a unary function.
/// ::
///  	y = UnaryFunctionLayer(x)
/// Requires 1 input and produces 1 output.
///
/// Input
///     A blob with shape ``[C]`` or ``[C, H, W]``.
/// Output
///     A blob with the same shape as the input.
///
/// The input is first modified by shifting and scaling:
/// 
/// .. math::
///     x \leftarrow \text{scale} \cdot x + \text{shift}
public struct CoreML_Specification_UnaryFunctionLayerParams: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".UnaryFunctionLayerParams"

  //// The type of unary function.
  public var type: CoreML_Specification_UnaryFunctionLayerParams.Operation = .sqrt

  ///*
  /// A constant used in ``POWER`` and ``THRESHOLD`` functions.
  public var alpha: Float = 0

  ///*
  /// A small constant to avoid division by 0 while normalizing variance.
  /// Defaults to ``1e-6`` if not set or set to ``0``.
  public var epsilon: Float = 0

  ///*
  /// Input is shifted by this amount 
  /// before the unary function is applied.
  /// Defaults to ``0.0`` if not set.
  public var shift: Float = 0

  ///*
  /// Input is scaled by this amount 
  /// before the unary function is applied.
  /// Defaults to ``1.0`` if not set or set to ``0``.
  public var scale: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  ///*
  /// A unary operator.
  ///
  /// The following functions are supported:
  ///
  /// ``SQRT``
  ///     .. math:: f(x) = \sqrt{x}
  ///
  /// ``RSQRT``
  ///     .. math:: f(x) = \dfrac{1}{\sqrt{x + \epsilon}}
  ///
  /// ``INVERSE``
  ///     .. math:: f(x) = \dfrac{1}{x + \epsilon}
  ///
  /// ``POWER``
  ///     .. math:: f(x) = x^\alpha
  ///
  /// ``EXP``
  ///     .. math:: f(x) = e^x
  ///
  /// ``LOG``
  ///     .. math:: f(x) = \log x
  ///
  /// ``ABS``
  ///     .. math:: f(x) = |x|
  ///
  /// ``THRESHOLD``
  ///     .. math:: f(x) = \text{max}(\alpha, x)
  public enum Operation: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case sqrt // = 0
    case rsqrt // = 1
    case inverse // = 2
    case power // = 3
    case exp // = 4
    case log // = 5
    case abs // = 6
    case threshold // = 7
    case UNRECOGNIZED(Int)

    public init() {
      self = .sqrt
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .sqrt
      case 1: self = .rsqrt
      case 2: self = .inverse
      case 3: self = .power
      case 4: self = .exp
      case 5: self = .log
      case 6: self = .abs
      case 7: self = .threshold
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .sqrt: return 0
      case .rsqrt: return 1
      case .inverse: return 2
      case .power: return 3
      case .exp: return 4
      case .log: return 5
      case .abs: return 6
      case .threshold: return 7
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.type)
      case 2: try decoder.decodeSingularFloatField(value: &self.alpha)
      case 3: try decoder.decodeSingularFloatField(value: &self.epsilon)
      case 4: try decoder.decodeSingularFloatField(value: &self.shift)
      case 5: try decoder.decodeSingularFloatField(value: &self.scale)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .sqrt {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if self.alpha != 0 {
      try visitor.visitSingularFloatField(value: self.alpha, fieldNumber: 2)
    }
    if self.epsilon != 0 {
      try visitor.visitSingularFloatField(value: self.epsilon, fieldNumber: 3)
    }
    if self.shift != 0 {
      try visitor.visitSingularFloatField(value: self.shift, fieldNumber: 4)
    }
    if self.scale != 0 {
      try visitor.visitSingularFloatField(value: self.scale, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// A layer that scales up spatial dimensions.  
/// It supports two modes: nearest neighbour (default) and bilinear. 
/// ::
///  	y = UpsampleLayer(x)
/// Requires 1 input and produces 1 output.
///
/// Input
///     A blob with shape ``[C, H, W]``.
/// Output
///     A blob with shape ``[C, scalingFactor[0] * H, scalingFactor[1] * W]``
public struct CoreML_Specification_UpsampleLayerParams: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".UpsampleLayerParams"

  ///*
  /// Scaling Factor. 
  /// Must be length 2 in order ``[H, W]``.
  /// If not set, default value ``[1, 1]`` is used.
  public var scalingFactor: [UInt64] = []

  public var mode: CoreML_Specification_UpsampleLayerParams.InterpolationMode = .nn

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum InterpolationMode: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    //// Nearest Neighbour
    case nn // = 0

    //// Bilinear
    case bilinear // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .nn
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .nn
      case 1: self = .bilinear
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .nn: return 0
      case .bilinear: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedUInt64Field(value: &self.scalingFactor)
      case 5: try decoder.decodeSingularEnumField(value: &self.mode)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.scalingFactor.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.scalingFactor, fieldNumber: 1)
    }
    if self.mode != .nn {
      try visitor.visitSingularEnumField(value: self.mode, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// A layer that performs elementwise addition of a bias,
/// which is broadcasted to match the input shape.
/// ::
///  	y = BiasLayer(x)
/// Requires 1 input and produces 1 output.
///
/// Input
///     A blob with shape ``[C, H, W]``.
/// Output
///     A blob with the same shape as the input.
public struct CoreML_Specification_BiasLayerParams: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".BiasLayerParams"

  ///*
  /// The shape of the bias. 
  /// Must be one of the following: 
  /// ``[1]``, ``[C]``, ``[1, H, W]`` or ``[C, H, W]``. 
  public var shape: [UInt64] {
    get {return _storage._shape}
    set {_uniqueStorage()._shape = newValue}
  }

  ///*
  /// The bias values.
  /// The size must be equal to the product of the ``shape`` dimensions.
  public var bias: CoreML_Specification_WeightParams {
    get {return _storage._bias ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._bias = newValue}
  }
  /// Returns true if `bias` has been explicitly set.
  public var hasBias: Bool {return _storage._bias != nil}
  /// Clears the value of `bias`. Subsequent reads from it will return its default value.
  public mutating func clearBias() {_storage._bias = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedUInt64Field(value: &_storage._shape)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._bias)
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._shape.isEmpty {
        try visitor.visitPackedUInt64Field(value: _storage._shape, fieldNumber: 1)
      }
      if let v = _storage._bias {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// A layer that performs elmentwise multiplication by a scale factor
/// and optionally adds a bias;
/// both the scale and bias are broadcasted to match the input shape.
/// ::
///  	y = ScaleLayer(x)
/// Requires 1 input and produces 1 output.
///
/// Input
///     A blob with shape ``[C, H, W]``.
/// Output
///     A blob with the same shape as the input.
public struct CoreML_Specification_ScaleLayerParams: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".ScaleLayerParams"

  ///*
  /// The shape of the scale. 
  /// Must be one of the following: 
  /// ``[1]``, ``[C]``, ``[1, H, W]`` or ``[C, H, W]``. 
  public var shapeScale: [UInt64] {
    get {return _storage._shapeScale}
    set {_uniqueStorage()._shapeScale = newValue}
  }

  ///*
  /// The scale values.
  /// The size must be equal to the product of the ``shape`` dimensions.
  public var scale: CoreML_Specification_WeightParams {
    get {return _storage._scale ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._scale = newValue}
  }
  /// Returns true if `scale` has been explicitly set.
  public var hasScale: Bool {return _storage._scale != nil}
  /// Clears the value of `scale`. Subsequent reads from it will return its default value.
  public mutating func clearScale() {_storage._scale = nil}

  //// If true, a bias is added after scaling.
  public var hasBias_p: Bool {
    get {return _storage._hasBias_p}
    set {_uniqueStorage()._hasBias_p = newValue}
  }

  ///*
  /// The shape of the bias. 
  /// Must be one of the following: 
  /// ``[1]``, ``[C]``, ``[1, H, W]`` or ``[C, H, W]``. 
  public var shapeBias: [UInt64] {
    get {return _storage._shapeBias}
    set {_uniqueStorage()._shapeBias = newValue}
  }

  ///*
  /// The bias values.
  /// The size must be equal to the product of the ``shape`` dimensions.
  public var bias: CoreML_Specification_WeightParams {
    get {return _storage._bias ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._bias = newValue}
  }
  /// Returns true if `bias` has been explicitly set.
  public var hasBias: Bool {return _storage._bias != nil}
  /// Clears the value of `bias`. Subsequent reads from it will return its default value.
  public mutating func clearBias() {_storage._bias = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedUInt64Field(value: &_storage._shapeScale)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._scale)
        case 3: try decoder.decodeSingularBoolField(value: &_storage._hasBias_p)
        case 4: try decoder.decodeRepeatedUInt64Field(value: &_storage._shapeBias)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._bias)
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._shapeScale.isEmpty {
        try visitor.visitPackedUInt64Field(value: _storage._shapeScale, fieldNumber: 1)
      }
      if let v = _storage._scale {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if _storage._hasBias_p != false {
        try visitor.visitSingularBoolField(value: _storage._hasBias_p, fieldNumber: 3)
      }
      if !_storage._shapeBias.isEmpty {
        try visitor.visitPackedUInt64Field(value: _storage._shapeBias, fieldNumber: 4)
      }
      if let v = _storage._bias {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// A layer that loads data as a parameter and provides it as an output.
/// ::
///  	y = LoadConstantLayer()
/// Takes no input. Produces 1 output.
///
/// Input
///     None
/// Output:
///     A blob with shape ``[C, H, W]``
public struct CoreML_Specification_LoadConstantLayerParams: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".LoadConstantLayerParams"

  ///*
  /// The shape of the constant to be loaded,
  /// which must be``[C, H, W]``.
  public var shape: [UInt64] {
    get {return _storage._shape}
    set {_uniqueStorage()._shape = newValue}
  }

  ///*
  /// The data values,
  /// of size ``C * H * W``.
  public var data: CoreML_Specification_WeightParams {
    get {return _storage._data ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {_storage._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedUInt64Field(value: &_storage._shape)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._data)
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._shape.isEmpty {
        try visitor.visitPackedUInt64Field(value: _storage._shape, fieldNumber: 1)
      }
      if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// A layer that performs L2 normalization, i.e. divides by the 
/// the square root of the sum of squares of all elements of input.
/// ::
/// 		y = L2NormalizeLayer(x)
/// Requires 1 input and produces 1 output.
///
/// Input
///     A blob with shape ``[C]`` or ``[C, H, W]``.
/// Output
///     A blob with the same shape as the input.
/// 
/// This layer is described by the following formula:
///
/// .. math::
///     x_i \leftarrow \dfrac{x_i}{\sqrt{\sum{x_i^2} + \epsilon}}
public struct CoreML_Specification_L2NormalizeLayerParams: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".L2NormalizeLayerParams"

  ///*
  /// A small constant to avoid division by 0 while normalizing variance.
  /// Defaults to ``1e-6`` if not set or set to ``0``.
  public var epsilon: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularFloatField(value: &self.epsilon)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.epsilon != 0 {
      try visitor.visitSingularFloatField(value: self.epsilon, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// A layer that flattens the input.
/// ::
/// 		y = FlattenLayer(x)
/// Requires 1 input and produces 1 output.
///
/// Input
///     A blob with shape ``[C, H, W]``.
/// Output
///     A blob with shape ``[C * H * W, 1, 1]``
///
/// There are two flatten orders: ``CHANNEL_FIRST`` and ``CHANNEL_LAST``.
/// ``CHANNEL_FIRST`` does not require data to be rearranged,
/// because row major ordering is used by internal storage.
/// ``CHANNEL_LAST`` requires data to be rearranged.
public struct CoreML_Specification_FlattenLayerParams: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".FlattenLayerParams"

  public var mode: CoreML_Specification_FlattenLayerParams.FlattenOrder = .channelFirst

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum FlattenOrder: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case channelFirst // = 0
    case channelLast // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .channelFirst
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .channelFirst
      case 1: self = .channelLast
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .channelFirst: return 0
      case .channelLast: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.mode)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.mode != .channelFirst {
      try visitor.visitSingularEnumField(value: self.mode, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// A layer that recasts the input into a new shape.
/// ::
///  	y = ReshapeLayer(x)
/// Requires 1 input and produces 1 output.
///
/// Input
///     A blob with shape ``[C, H, W]`` or ``[Seq, C, H, W]``.
/// Output
///     A blob with shape ``[C_out, H_out, W_out]`` 
///     or ``[Seq_out, C_out, H_out, W_out]``.
///
/// There are two reshape orders: ``CHANNEL_FIRST`` and ``CHANNEL_LAST``.
/// ``CHANNEL_FIRST`` is equivalent to 
/// flattening the input to ``[C * H * W, 1, 1]`` in channel first order
/// and then reshaping it to the target shape;
/// no data rearrangement is required.
/// ``CHANNEL_LAST`` is equivalent to
/// flattening the input to ``[H * W * C, 1, 1]`` in channel last order,
/// reshaping it to ``[H_out, W_out, C_out]`` (it is now in "H_out-major"" order),
/// and then permuting it to ``[C_out, H_out, W_out]``;
/// both the flattening and permuting requires the data to be rearranged.
public struct CoreML_Specification_ReshapeLayerParams: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".ReshapeLayerParams"

  ///*
  /// The shape of the output. 
  /// Must be of length 3 or 4.
  /// If set to 3, ``targetShape`` is interpreted as 
  /// ``[C_out, H_out, W_out]``, and sequence length of the input is preserved.
  /// If set to 4, ``targetShape`` is interpreted as
  /// ``[Seq_out, C_out, H_out, W_out]``, 
  /// where ``Seq_out`` is the new sequence length.
  public var targetShape: [Int64] = []

  public var mode: CoreML_Specification_ReshapeLayerParams.ReshapeOrder = .channelFirst

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum ReshapeOrder: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case channelFirst // = 0
    case channelLast // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .channelFirst
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .channelFirst
      case 1: self = .channelLast
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .channelFirst: return 0
      case .channelLast: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedInt64Field(value: &self.targetShape)
      case 2: try decoder.decodeSingularEnumField(value: &self.mode)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.targetShape.isEmpty {
      try visitor.visitPackedInt64Field(value: self.targetShape, fieldNumber: 1)
    }
    if self.mode != .channelFirst {
      try visitor.visitSingularEnumField(value: self.mode, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// A layer that rearranges the dimensions and data of an input.
/// ::
///  	y = PermuteLayer(x)
/// Requires 1 input and produces 1 output.
///
/// Input
///     A sequence of 3-dimensional blobs. ``InputShape = [Seq, C, H, W]``.
/// Output
///     A sequence of a different length of 3-dimensional blobs.
///     Shape: ``[InputShape[axis[0]], InputShape[axis[1]],
///     InputShape[axis[2]], InputShape[axis[3]]]``. Hence output is a sequence of length ``InputShape[axis[0]]``.
/// 
/// Examples:
///
/// - If ``axis`` is set to ``[0, 3, 1, 2]``, 
///   then the output has shape ``[W,C,H]`` 
///   and has the same sequence length that of the input.
///
/// - If ``axis`` is set to ``[3, 1, 2, 0]``, 
///   and the input is a sequence of data 
///   with length ``Seq`` and shape ``[C, 1, 1]``, 
///   then the output is a unit sequence of data with shape ``[C, 1, Seq]``.
///
/// - If ``axis`` is set to ``[0, 3, 2, 1]``,
///   the output is a reverse of the input: ``[C, H, W] -> [W, H, C]``.
///
/// - If ``axis`` is not set, or is set to ``[0, 1, 2, 3]``,
///   the output is the same as the input.
public struct CoreML_Specification_PermuteLayerParams: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".PermuteLayerParams"

  ///*
  ///The order in which to permute the dimensions.
  ///Must have length 4 and a permutation of ``[0, 1, 2, 3]``.
  public var axis: [UInt64] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedUInt64Field(value: &self.axis)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.axis.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.axis, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// A layer that reorganizes data in the input in specific ways.
/// ::
///  	y = ReorganizeDataLayer(x)
/// Requires 1 input and produces 1 output.
///
/// Input
///     A blob with shape ``[C, H, W]``.
/// Output
///     A blob with shape ``[C_out, H_out, W_out]``.
///
/// mode == SPACE_TO_DEPTH
///  ``[C_out, H_out, W_out]`` : ``[C * blockSize * blockSize, H/blockSize, W/blockSize]``.
///  blockSize must divide H and W.
///	Data is moved from the spatial dimensions to the channel dimension. Input is spatially divided into 
///  non-overlapping blocks of size blockSize X blockSize and data from each block is moved into the 
///  channel dimension. 
///
/// mode == DEPTH_TO_SPACE
/// ``[C_out, H_out, W_out]`` : ``[C/(blockSize * blockSize), H * blockSize, W * blockSize]``.
///  Square of blockSize must divide C.
///  Reverse of SPACE_TO_DEPTH. Data is moved from the channel dimension to the spatial dimenions. 
public struct CoreML_Specification_ReorganizeDataLayerParams: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".ReorganizeDataLayerParams"

  public var mode: CoreML_Specification_ReorganizeDataLayerParams.ReorganizationType = .spaceToDepth

  //// must be greater than 1
  public var blockSize: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum ReorganizationType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case spaceToDepth // = 0
    case depthToSpace // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .spaceToDepth
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .spaceToDepth
      case 1: self = .depthToSpace
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .spaceToDepth: return 0
      case .depthToSpace: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.mode)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.blockSize)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.mode != .spaceToDepth {
      try visitor.visitSingularEnumField(value: self.mode, fieldNumber: 1)
    }
    if self.blockSize != 0 {
      try visitor.visitSingularUInt64Field(value: self.blockSize, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// A layer that slices the input data along a given axis. 
/// ::
///  	y = SliceLayer(x)
/// Requires 1 input and produces 1 output.
///
/// Input
///     A blob with shape ``[Seq, C, H, W]``.
/// Output
///     A blob with shape ``[Seq_out, C_out, H_out, W_out]``.
///
/// Sliced section is taken from the interval ``[startIndex, endIndex)``, i.e.
/// startIndex is inclusive while endIndex is exclusive. 
/// stride must be positive and represents the step size for slicing. 
/// startIndex must be non-negative. Negative indexing is supported for endIndex: -1 denotes N, -2 denotes N-1
/// and so on, where N is the length of the dimension to be sliced. 
public struct CoreML_Specification_SliceLayerParams: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".SliceLayerParams"

  //// start of the sliced section. Inclusive. 
  public var startIndex: UInt64 = 0

  //// end of sliced section. Exclusive.
  public var endIndex: Int64 = 0

  //// The step size. Must be postive.
  public var stride: UInt64 = 0

  public var axis: CoreML_Specification_SliceLayerParams.SliceAxis = .channelAxis

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum SliceAxis: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case channelAxis // = 0
    case heightAxis // = 1
    case widthAxis // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .channelAxis
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .channelAxis
      case 1: self = .heightAxis
      case 2: self = .widthAxis
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .channelAxis: return 0
      case .heightAxis: return 1
      case .widthAxis: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.startIndex)
      case 2: try decoder.decodeSingularInt64Field(value: &self.endIndex)
      case 3: try decoder.decodeSingularUInt64Field(value: &self.stride)
      case 4: try decoder.decodeSingularEnumField(value: &self.axis)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.startIndex != 0 {
      try visitor.visitSingularUInt64Field(value: self.startIndex, fieldNumber: 1)
    }
    if self.endIndex != 0 {
      try visitor.visitSingularInt64Field(value: self.endIndex, fieldNumber: 2)
    }
    if self.stride != 0 {
      try visitor.visitSingularUInt64Field(value: self.stride, fieldNumber: 3)
    }
    if self.axis != .channelAxis {
      try visitor.visitSingularEnumField(value: self.axis, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// A layer that reduces the input using a specified operation.
/// ::
/// 		y = ReduceLayer(x)
/// Requires 1 input and produces 1 output.
///
/// Input
///     A blob with shape ``[C, H, W]``.
/// Output
///     A blob whose shape depends on the value of axis, the dimension(s) along which reduction is performed.  
///     if axis == C   : ``[1, H, W]``
///     if axis == H   : ``[C, 1, W]``
///     if axis == W   : ``[C, H, 1]``
///     if axis == HW  : ``[C, 1, 1]``
///     if axis == CHW : ``[1, 1, 1]`` [Default]
public struct CoreML_Specification_ReduceLayerParams: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".ReduceLayerParams"

  //// Specifies function used to reduce.
  public var mode: CoreML_Specification_ReduceLayerParams.ReduceOperation = .sum

  ///*
  /// Used if mode is ``LOGSUM``.
  /// Defaults to ``1e-6`` if not set or is set to ``0``.
  public var epsilon: Float = 0

  public var axis: CoreML_Specification_ReduceLayerParams.ReduceAxis = .chw

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  ///
  /// The following reduction operations are supported
  /// and are applied on the specified axis of the input array:
  ///
  /// ``SUM``
  ///     Sum of all elements
  ///
  ///     .. math:: \sum{x_i}
  ///
  /// ``AVG``
  ///     Sum of all elements divided by the number of elements
  ///
  ///     .. math:: \dfrac{\sum^n{x_i}}{n}
  ///
  /// ``PROD``
  ///     Product of all elements
  ///
  ///     .. math:: \prod{x_i}
  ///
  /// ``LOGSUM``
  ///     Sum of the natural logarithm of all elements
  ///
  ///     .. math:: \sum{\ln{(x_i + \epsilon)}}
  ///
  /// ``SUMSQUARE``
  ///     Sum of squares of all elements
  ///
  ///     .. math:: \sum{x^2}
  ///
  /// ``L1``
  ///     L1 normalization of all elements
  ///
  ///     .. math:: ||x||_1 = \sum{|x_i|}
  ///
  /// ``L2``
  ///     L2 normalization of all elements
  ///
  ///     .. math:: ||x||_2 = \sqrt{\sum{x_i^2}}
  ///
  /// ``MAX``
  ///     Maximum of all elements
  ///    
  ///     .. math:: \text{max}(x_i)
  ///
  /// ``MIN``
  ///     Minumum of all elements
  ///    
  ///     .. math:: \text{min}(x_i)
  ///
  /// ``ARGMAX``
  ///     Argument of the maximum of all elements
  ///    
  ///     .. math:: \text{argmax}(x_i)
  public enum ReduceOperation: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case sum // = 0
    case avg // = 1
    case prod // = 2
    case logsum // = 3
    case sumsquare // = 4
    case l1 // = 5
    case l2 // = 6
    case max // = 7
    case min // = 8

    //// only supported with axis = C, H or W.
    case argmax // = 9
    case UNRECOGNIZED(Int)

    public init() {
      self = .sum
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .sum
      case 1: self = .avg
      case 2: self = .prod
      case 3: self = .logsum
      case 4: self = .sumsquare
      case 5: self = .l1
      case 6: self = .l2
      case 7: self = .max
      case 8: self = .min
      case 9: self = .argmax
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .sum: return 0
      case .avg: return 1
      case .prod: return 2
      case .logsum: return 3
      case .sumsquare: return 4
      case .l1: return 5
      case .l2: return 6
      case .max: return 7
      case .min: return 8
      case .argmax: return 9
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum ReduceAxis: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case chw // = 0
    case hw // = 1
    case c // = 2
    case h // = 3
    case w // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .chw
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .chw
      case 1: self = .hw
      case 2: self = .c
      case 3: self = .h
      case 4: self = .w
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .chw: return 0
      case .hw: return 1
      case .c: return 2
      case .h: return 3
      case .w: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.mode)
      case 2: try decoder.decodeSingularFloatField(value: &self.epsilon)
      case 3: try decoder.decodeSingularEnumField(value: &self.axis)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.mode != .sum {
      try visitor.visitSingularEnumField(value: self.mode, fieldNumber: 1)
    }
    if self.epsilon != 0 {
      try visitor.visitSingularFloatField(value: self.epsilon, fieldNumber: 2)
    }
    if self.axis != .chw {
      try visitor.visitSingularEnumField(value: self.axis, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// A layer that crops the spatial dimensions of an input.
/// If two inputs are provided, the shape of the second input is used as the reference shape.
/// ::
///  	y = CropLayer(x1) or y = CropLayer(x1,x2)  
/// Requires 1 or 2 inputs and produces 1 output. 
///
/// Input
///     - 1 input case: A blob with shape ``[C, H_in, W_in]``.
///     - 2 input case: 1st blob with shape ``[C, H_in, W_in]``, 2nd blob with shape ``[C, H_out, W_out]``.
///     
/// Output
///     A blob with shape ``[C, H_out, W_out]``.
///
/// If one input is used, output is computed as follows: 
/// ::
/// 		y = x1[:, topCropAmount:H_in - bottomCropAmount, leftCropAmount:W_in - rightCropAmount]
///
/// 		topCropAmount == Height startEdgeSize == borderAmounts[0].startEdgeSize
/// 		bottomCropAmount == Height endEdgeSize == borderAmounts[0].endEdgeSize
/// 		leftCropAmount == Width startEdgeSize == borderAmounts[1].startEdgeSize
/// 		rightCropAmount == Width endEdgeSize == borderAmounts[1].endEdgeSize
/// 		
/// 		H_out = H_in - topCropAmount - bottomCropAmount
/// 		W_out = W_in - leftCropAmount - rightCropAmount
///
/// If two inputs are used, output is computed as follows: 
/// ::
/// 		y = x1[:, offset[0]:offset[0] + H_out, offset[1]:offset[1] + W_out]
public struct CoreML_Specification_CropLayerParams: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".CropLayerParams"

  ///*
  /// The amounts to be cropped from the input. 
  /// Used only if a single input is provided.
  public var cropAmounts: CoreML_Specification_BorderAmounts {
    get {return _storage._cropAmounts ?? CoreML_Specification_BorderAmounts()}
    set {_uniqueStorage()._cropAmounts = newValue}
  }
  /// Returns true if `cropAmounts` has been explicitly set.
  public var hasCropAmounts: Bool {return _storage._cropAmounts != nil}
  /// Clears the value of `cropAmounts`. Subsequent reads from it will return its default value.
  public mutating func clearCropAmounts() {_storage._cropAmounts = nil}

  ///*
  /// The offset amounts. 
  /// Used only if two inputs are provided.
  /// Must be of length 2, in order ``[H, W]``.
  public var offset: [UInt64] {
    get {return _storage._offset}
    set {_uniqueStorage()._offset = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._cropAmounts)
        case 5: try decoder.decodeRepeatedUInt64Field(value: &_storage._offset)
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._cropAmounts {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._offset.isEmpty {
        try visitor.visitPackedUInt64Field(value: _storage._offset, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// A layer that computes the elementwise average of the inputs.
/// ::
/// 		y = AverageLayer(x1,x2,...)
/// Requires multiple inputs and produces 1 output.
///
/// Input
///     Multiple blobs with broadcastable shapes ``[1]``, ``[C]``, ``[1, H, W]``, or ``[C, H, W]``.
/// Output
///     A blob with the same shape as each input.
public struct CoreML_Specification_AverageLayerParams: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".AverageLayerParams"

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// A layer that computes the elementwise maximum over the inputs.
/// ::
/// 		y = MaxLayer(x1,x2,...)
/// Requires multiple inputs and produces 1 output. 
///
/// Input
///     Multiple blobs, each with shape ``[C]`` or ``[C, H, W]``.
/// Output
///     A blob with the same shape as each input.
public struct CoreML_Specification_MaxLayerParams: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".MaxLayerParams"

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// A layer that computes the elementwise minimum over the inputs.
/// ::
/// 		y = MinLayer(x1,x2,...)
/// Requires multiple inputs and produces 1 output.
///
/// Input
///     Multiple blobs, each with shape ``[C]`` or ``[C, H, W]``.
/// Output
///     A blob with the same shape as each input.
public struct CoreML_Specification_MinLayerParams: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".MinLayerParams"

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// A layer that computes the dot product of two vectors.
/// ::
/// 		y = DotProductLayer(x1,x2)
/// Requires 2 inputs and produces 1 output.
///
/// Input
///     Two blobs with shape ``[C]``.
/// Output
///     A scalar.
public struct CoreML_Specification_DotProductLayerParams: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".DotProductLayerParams"

  ///*
  /// If true, inputs are normalized first,
  /// thereby computing the cosine similarity.
  public var cosineSimilarity: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.cosineSimilarity)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.cosineSimilarity != false {
      try visitor.visitSingularBoolField(value: self.cosineSimilarity, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// A layer that performs mean variance normalization.
/// ::
/// 		y = MeanVarianceNormalizeLayer(x)
/// Requires 1 input and produces 1 output.
///
/// Input
///     A blob with shape ``[C]`` or ``[C, H, W]``.
/// Output
///     A blob with the same shape as the input.
///
/// If ``acrossChannels == true`` 
/// normalization is performed on flattened input.
///
/// If ``acrossChannels == false`` 
/// normalization is performed within a channel, 
/// across spatial dimensions.
public struct CoreML_Specification_MeanVarianceNormalizeLayerParams: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".MeanVarianceNormalizeLayerParams"

  ///*
  /// If true, mean and variance are computed across channels.
  public var acrossChannels: Bool = false

  ///*
  /// If false, only mean is subtracted.
  public var normalizeVariance: Bool = false

  ///*
  /// A small constant to avoid division by 0 while normalizing variance.
  /// Defaults to ``1e-6`` if not set or set to ``0``.
  public var epsilon: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.acrossChannels)
      case 2: try decoder.decodeSingularBoolField(value: &self.normalizeVariance)
      case 3: try decoder.decodeSingularFloatField(value: &self.epsilon)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.acrossChannels != false {
      try visitor.visitSingularBoolField(value: self.acrossChannels, fieldNumber: 1)
    }
    if self.normalizeVariance != false {
      try visitor.visitSingularBoolField(value: self.normalizeVariance, fieldNumber: 2)
    }
    if self.epsilon != 0 {
      try visitor.visitSingularFloatField(value: self.epsilon, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// A layer that repeats a sequence.
/// ::
/// 		y = SequenceRepeatLayer(x)
/// Requires 1 input and produces 1 output.
///
/// Input
///     A sequence of blobs, i.e. shape is either ``[Seq, C]`` or ``[Seq, C, H, W]``.
/// Output
///     A sequence of length ``nRepetitions * Seq`` 
///     with shape corresponding to the input,
///     i.e. shape is either ``[nRepetitions * Seq, C]`` or ``[nRepetitions * Seq, C, H, W]``.
public struct CoreML_Specification_SequenceRepeatLayerParams: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".SequenceRepeatLayerParams"

  ///*
  /// Number of repetitions.
  /// Defaults to ``1`` if not set or set to ``0``.
  public var nRepetitions: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.nRepetitions)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.nRepetitions != 0 {
      try visitor.visitSingularUInt64Field(value: self.nRepetitions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// A simple recurrent layer.
/// ::
/// 		y_t = SimpleRecurrentLayer(x_t, y_{t-1})
///
/// Input
///    A sequence of vectors of size ``inputVectorSize``
///    with shape ``[Seq, inputVectorSize]``.
/// Output
///    A vector of size ``outputVectorSize``. It is either the final output or a sequence of outputs at all time steps.  
/// - Output Shape: ``[1,outputVectorSize]`` , if ``sequenceOutput == false``
/// - Output Shape: ``[Seq,outputVectorSize]`` , if ``sequenceOutput == true``
///
/// This layer is described by the following equation:
///
/// .. math::
///     \boldsymbol{y_t} = f(\mathrm{clip}(W \boldsymbol{x_t} + \
///                                        R \boldsymbol{y_{t-1}} + b))
///
/// - ``W`` is a 2-dimensional weight matrix
///   (``[outputVectorSize, inputVectorSize]``, row-major)
/// - ``R`` is a 2-dimensional recursion matrix
///   (``[outputVectorSize, outputVectorSize]``, row-major)
/// - ``b`` is a 1-dimensional bias vector (``[outputVectorSize]``)
/// - ``f()`` is an activation
/// - ``clip()`` is a function that constrains values between ``[-50.0, 50.0]``
public struct CoreML_Specification_SimpleRecurrentLayerParams: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".SimpleRecurrentLayerParams"

  //// The size of the input vectors.
  public var inputVectorSize: UInt64 {
    get {return _storage._inputVectorSize}
    set {_uniqueStorage()._inputVectorSize = newValue}
  }

  //// The size of the output vectors.
  public var outputVectorSize: UInt64 {
    get {return _storage._outputVectorSize}
    set {_uniqueStorage()._outputVectorSize = newValue}
  }

  ///*
  /// Activations supported are Linear, Sigmoid, Tanh, ReLU, Scaled Tanh (alpha = 1.71, beta = 2/3), Hard sigmoid (alpha = 0.2, beta = 0.5)
  public var activation: CoreML_Specification_ActivationParams {
    get {return _storage._activation ?? CoreML_Specification_ActivationParams()}
    set {_uniqueStorage()._activation = newValue}
  }
  /// Returns true if `activation` has been explicitly set.
  public var hasActivation: Bool {return _storage._activation != nil}
  /// Clears the value of `activation`. Subsequent reads from it will return its default value.
  public mutating func clearActivation() {_storage._activation = nil}

  ///*
  ///If false output is just the result after final state update.
  ///If true, output is a sequence, containing outputs at all time steps.
  public var sequenceOutput: Bool {
    get {return _storage._sequenceOutput}
    set {_uniqueStorage()._sequenceOutput = newValue}
  }

  //// If false, no bias is added.
  public var hasBiasVector_p: Bool {
    get {return _storage._hasBiasVector_p}
    set {_uniqueStorage()._hasBiasVector_p = newValue}
  }

  //// Weight matrix W.
  public var weightMatrix: CoreML_Specification_WeightParams {
    get {return _storage._weightMatrix ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._weightMatrix = newValue}
  }
  /// Returns true if `weightMatrix` has been explicitly set.
  public var hasWeightMatrix: Bool {return _storage._weightMatrix != nil}
  /// Clears the value of `weightMatrix`. Subsequent reads from it will return its default value.
  public mutating func clearWeightMatrix() {_storage._weightMatrix = nil}

  //// Recursion Weight matrix R.
  public var recursionMatrix: CoreML_Specification_WeightParams {
    get {return _storage._recursionMatrix ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._recursionMatrix = newValue}
  }
  /// Returns true if `recursionMatrix` has been explicitly set.
  public var hasRecursionMatrix: Bool {return _storage._recursionMatrix != nil}
  /// Clears the value of `recursionMatrix`. Subsequent reads from it will return its default value.
  public mutating func clearRecursionMatrix() {_storage._recursionMatrix = nil}

  //// Bias vector b.
  public var biasVector: CoreML_Specification_WeightParams {
    get {return _storage._biasVector ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._biasVector = newValue}
  }
  /// Returns true if `biasVector` has been explicitly set.
  public var hasBiasVector: Bool {return _storage._biasVector != nil}
  /// Clears the value of `biasVector`. Subsequent reads from it will return its default value.
  public mutating func clearBiasVector() {_storage._biasVector = nil}

  /// If true, then the node processes the input sequence from right to left
  public var reverseInput: Bool {
    get {return _storage._reverseInput}
    set {_uniqueStorage()._reverseInput = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt64Field(value: &_storage._inputVectorSize)
        case 2: try decoder.decodeSingularUInt64Field(value: &_storage._outputVectorSize)
        case 10: try decoder.decodeSingularMessageField(value: &_storage._activation)
        case 15: try decoder.decodeSingularBoolField(value: &_storage._sequenceOutput)
        case 20: try decoder.decodeSingularBoolField(value: &_storage._hasBiasVector_p)
        case 30: try decoder.decodeSingularMessageField(value: &_storage._weightMatrix)
        case 31: try decoder.decodeSingularMessageField(value: &_storage._recursionMatrix)
        case 32: try decoder.decodeSingularMessageField(value: &_storage._biasVector)
        case 100: try decoder.decodeSingularBoolField(value: &_storage._reverseInput)
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._inputVectorSize != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._inputVectorSize, fieldNumber: 1)
      }
      if _storage._outputVectorSize != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._outputVectorSize, fieldNumber: 2)
      }
      if let v = _storage._activation {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if _storage._sequenceOutput != false {
        try visitor.visitSingularBoolField(value: _storage._sequenceOutput, fieldNumber: 15)
      }
      if _storage._hasBiasVector_p != false {
        try visitor.visitSingularBoolField(value: _storage._hasBiasVector_p, fieldNumber: 20)
      }
      if let v = _storage._weightMatrix {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
      }
      if let v = _storage._recursionMatrix {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
      }
      if let v = _storage._biasVector {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
      }
      if _storage._reverseInput != false {
        try visitor.visitSingularBoolField(value: _storage._reverseInput, fieldNumber: 100)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// Gated-Recurrent Unit (GRU) Layer
/// ::
/// 		y_t = GRULayer(x_t, y_{t-1})
///
/// Input
///    A sequence of vectors of size ``inputVectorSize``
///    with shape ``[Seq, inputVectorSize]``.
/// Output
///    A vector of size ``outputVectorSize``. It is either the final output or a sequence of outputs at all time steps.  
/// - Output Shape: ``[1,outputVectorSize]`` , if ``sequenceOutput == false``
/// - Output Shape: ``[Seq,outputVectorSize]`` , if ``sequenceOutput == true``
///
/// This layer is described by the following equations:
///
/// Update Gate
///     .. math::
///         \boldsymbol{z_t} = \
///             f(\mathrm{clip}(W_z \boldsymbol{x_t} + \
///                             R_z \boldsymbol{y_{t-1}} + b_z)
///
/// Reset Gate
///     .. math::
///         \boldsymbol{r_t} = \
///             f(\mathrm{clip}(W_r \boldsymbol{x_t} + \
///                             R_r \boldsymbol{y_{t-1}} + b_r))
///
/// Cell Memory State
///     .. math::
///         \boldsymbol{c_t} = \
///             \boldsymbol{y_{t-1}} \odot \boldsymbol{r_t}
///
/// Output Gate
///     .. math::
///         \boldsymbol{o_t} = \
///             g(\mathrm{clip}(W_o \boldsymbol{x_t} + \
///                             R_o \boldsymbol{c_t} + b_o))
///
/// Output
///     .. math::
///         \boldsymbol{y_t} = \
///             (1 - \boldsymbol{z_t}) \odot \boldsymbol{o_t} + \
///              \boldsymbol{z_t} \odot \boldsymbol{y_{t-1}}
///
/// - ``W_z``, ``W_r``, ``W_o`` are 2-dimensional input weight matrices
///   (``[outputVectorSize, inputVectorSize]``, row-major)
/// - ``R_z``, ``R_r``, ``R_o`` are 2-dimensional recursion matrices
///   (``[outputVectorSize, outputVectorSize]``, row-major)
/// - ``b_z``, ``b_r``, ``b_o`` are 1-dimensional bias vectors
///   (``[outputVectorSize]``)
/// - ``f()``, ``g()`` are activations
/// - ``clip()`` is a function that constrains values between ``[-50.0, 50.0]``
/// - ``⊙`` denotes the elementwise product of matrices
public struct CoreML_Specification_GRULayerParams: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".GRULayerParams"

  //// Size of the input vectors.
  public var inputVectorSize: UInt64 {
    get {return _storage._inputVectorSize}
    set {_uniqueStorage()._inputVectorSize = newValue}
  }

  //// Size of the output vectors.
  public var outputVectorSize: UInt64 {
    get {return _storage._outputVectorSize}
    set {_uniqueStorage()._outputVectorSize = newValue}
  }

  ///*
  /// 2 element array representing activations [f(), g()] in that order.
  /// Typical values used = [sigmoid, tanh].
  /// Activations supported are Linear, Sigmoid, Tanh, ReLU, Scaled Tanh (alpha = 1.71, beta = 2/3), Hard sigmoid (alpha = 0.2, beta = 0.5)
  public var activations: [CoreML_Specification_ActivationParams] {
    get {return _storage._activations}
    set {_uniqueStorage()._activations = newValue}
  }

  ///*
  /// If false output is just the result after final state update.
  /// If true, output is a sequence, containing outputs at all time steps.
  public var sequenceOutput: Bool {
    get {return _storage._sequenceOutput}
    set {_uniqueStorage()._sequenceOutput = newValue}
  }

  ///*
  /// If false, no biases (``b_z``, ``b_r``, ``b_o``) are added.
  public var hasBiasVectors_p: Bool {
    get {return _storage._hasBiasVectors_p}
    set {_uniqueStorage()._hasBiasVectors_p = newValue}
  }

  //// Weight Matrix W_z.
  public var updateGateWeightMatrix: CoreML_Specification_WeightParams {
    get {return _storage._updateGateWeightMatrix ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._updateGateWeightMatrix = newValue}
  }
  /// Returns true if `updateGateWeightMatrix` has been explicitly set.
  public var hasUpdateGateWeightMatrix: Bool {return _storage._updateGateWeightMatrix != nil}
  /// Clears the value of `updateGateWeightMatrix`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateGateWeightMatrix() {_storage._updateGateWeightMatrix = nil}

  //// Weight Matrix W_r.
  public var resetGateWeightMatrix: CoreML_Specification_WeightParams {
    get {return _storage._resetGateWeightMatrix ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._resetGateWeightMatrix = newValue}
  }
  /// Returns true if `resetGateWeightMatrix` has been explicitly set.
  public var hasResetGateWeightMatrix: Bool {return _storage._resetGateWeightMatrix != nil}
  /// Clears the value of `resetGateWeightMatrix`. Subsequent reads from it will return its default value.
  public mutating func clearResetGateWeightMatrix() {_storage._resetGateWeightMatrix = nil}

  //// Weight Matrix W_o.
  public var outputGateWeightMatrix: CoreML_Specification_WeightParams {
    get {return _storage._outputGateWeightMatrix ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._outputGateWeightMatrix = newValue}
  }
  /// Returns true if `outputGateWeightMatrix` has been explicitly set.
  public var hasOutputGateWeightMatrix: Bool {return _storage._outputGateWeightMatrix != nil}
  /// Clears the value of `outputGateWeightMatrix`. Subsequent reads from it will return its default value.
  public mutating func clearOutputGateWeightMatrix() {_storage._outputGateWeightMatrix = nil}

  //// Recursion Weight Matrix R_z.
  public var updateGateRecursionMatrix: CoreML_Specification_WeightParams {
    get {return _storage._updateGateRecursionMatrix ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._updateGateRecursionMatrix = newValue}
  }
  /// Returns true if `updateGateRecursionMatrix` has been explicitly set.
  public var hasUpdateGateRecursionMatrix: Bool {return _storage._updateGateRecursionMatrix != nil}
  /// Clears the value of `updateGateRecursionMatrix`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateGateRecursionMatrix() {_storage._updateGateRecursionMatrix = nil}

  //// Recursion Weight Matrix R_r.
  public var resetGateRecursionMatrix: CoreML_Specification_WeightParams {
    get {return _storage._resetGateRecursionMatrix ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._resetGateRecursionMatrix = newValue}
  }
  /// Returns true if `resetGateRecursionMatrix` has been explicitly set.
  public var hasResetGateRecursionMatrix: Bool {return _storage._resetGateRecursionMatrix != nil}
  /// Clears the value of `resetGateRecursionMatrix`. Subsequent reads from it will return its default value.
  public mutating func clearResetGateRecursionMatrix() {_storage._resetGateRecursionMatrix = nil}

  //// Recursion Weight Matrix R_o.
  public var outputGateRecursionMatrix: CoreML_Specification_WeightParams {
    get {return _storage._outputGateRecursionMatrix ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._outputGateRecursionMatrix = newValue}
  }
  /// Returns true if `outputGateRecursionMatrix` has been explicitly set.
  public var hasOutputGateRecursionMatrix: Bool {return _storage._outputGateRecursionMatrix != nil}
  /// Clears the value of `outputGateRecursionMatrix`. Subsequent reads from it will return its default value.
  public mutating func clearOutputGateRecursionMatrix() {_storage._outputGateRecursionMatrix = nil}

  //// Bias vector b_z.
  public var updateGateBiasVector: CoreML_Specification_WeightParams {
    get {return _storage._updateGateBiasVector ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._updateGateBiasVector = newValue}
  }
  /// Returns true if `updateGateBiasVector` has been explicitly set.
  public var hasUpdateGateBiasVector: Bool {return _storage._updateGateBiasVector != nil}
  /// Clears the value of `updateGateBiasVector`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateGateBiasVector() {_storage._updateGateBiasVector = nil}

  //// Bias vector b_r.
  public var resetGateBiasVector: CoreML_Specification_WeightParams {
    get {return _storage._resetGateBiasVector ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._resetGateBiasVector = newValue}
  }
  /// Returns true if `resetGateBiasVector` has been explicitly set.
  public var hasResetGateBiasVector: Bool {return _storage._resetGateBiasVector != nil}
  /// Clears the value of `resetGateBiasVector`. Subsequent reads from it will return its default value.
  public mutating func clearResetGateBiasVector() {_storage._resetGateBiasVector = nil}

  //// Bias vector b_o.
  public var outputGateBiasVector: CoreML_Specification_WeightParams {
    get {return _storage._outputGateBiasVector ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._outputGateBiasVector = newValue}
  }
  /// Returns true if `outputGateBiasVector` has been explicitly set.
  public var hasOutputGateBiasVector: Bool {return _storage._outputGateBiasVector != nil}
  /// Clears the value of `outputGateBiasVector`. Subsequent reads from it will return its default value.
  public mutating func clearOutputGateBiasVector() {_storage._outputGateBiasVector = nil}

  //// If true, then the node processes the input sequence from right to left
  public var reverseInput: Bool {
    get {return _storage._reverseInput}
    set {_uniqueStorage()._reverseInput = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt64Field(value: &_storage._inputVectorSize)
        case 2: try decoder.decodeSingularUInt64Field(value: &_storage._outputVectorSize)
        case 10: try decoder.decodeRepeatedMessageField(value: &_storage._activations)
        case 15: try decoder.decodeSingularBoolField(value: &_storage._sequenceOutput)
        case 20: try decoder.decodeSingularBoolField(value: &_storage._hasBiasVectors_p)
        case 30: try decoder.decodeSingularMessageField(value: &_storage._updateGateWeightMatrix)
        case 31: try decoder.decodeSingularMessageField(value: &_storage._resetGateWeightMatrix)
        case 32: try decoder.decodeSingularMessageField(value: &_storage._outputGateWeightMatrix)
        case 50: try decoder.decodeSingularMessageField(value: &_storage._updateGateRecursionMatrix)
        case 51: try decoder.decodeSingularMessageField(value: &_storage._resetGateRecursionMatrix)
        case 52: try decoder.decodeSingularMessageField(value: &_storage._outputGateRecursionMatrix)
        case 70: try decoder.decodeSingularMessageField(value: &_storage._updateGateBiasVector)
        case 71: try decoder.decodeSingularMessageField(value: &_storage._resetGateBiasVector)
        case 72: try decoder.decodeSingularMessageField(value: &_storage._outputGateBiasVector)
        case 100: try decoder.decodeSingularBoolField(value: &_storage._reverseInput)
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._inputVectorSize != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._inputVectorSize, fieldNumber: 1)
      }
      if _storage._outputVectorSize != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._outputVectorSize, fieldNumber: 2)
      }
      if !_storage._activations.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._activations, fieldNumber: 10)
      }
      if _storage._sequenceOutput != false {
        try visitor.visitSingularBoolField(value: _storage._sequenceOutput, fieldNumber: 15)
      }
      if _storage._hasBiasVectors_p != false {
        try visitor.visitSingularBoolField(value: _storage._hasBiasVectors_p, fieldNumber: 20)
      }
      if let v = _storage._updateGateWeightMatrix {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
      }
      if let v = _storage._resetGateWeightMatrix {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
      }
      if let v = _storage._outputGateWeightMatrix {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
      }
      if let v = _storage._updateGateRecursionMatrix {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 50)
      }
      if let v = _storage._resetGateRecursionMatrix {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 51)
      }
      if let v = _storage._outputGateRecursionMatrix {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 52)
      }
      if let v = _storage._updateGateBiasVector {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 70)
      }
      if let v = _storage._resetGateBiasVector {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 71)
      }
      if let v = _storage._outputGateBiasVector {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 72)
      }
      if _storage._reverseInput != false {
        try visitor.visitSingularBoolField(value: _storage._reverseInput, fieldNumber: 100)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// Long short-term memory (LSTM) parameters.
///
/// This is described by the following equations:
///
/// Input Gate
///     .. math::
///         \boldsymbol{i_t} = \
///             f(\mathrm{clip}(W_i \boldsymbol{x_t} + \
///                             R_i \boldsymbol{y_{t-1}} + \
///                             p_i \odot c_{t-1} + b_i))
///
/// Forget Gate
///     .. math::
///         \boldsymbol{f_t} = \
///             f(\mathrm{clip}(W_f \boldsymbol{x_t} + \
///                             R_f \boldsymbol{y_{t-1}} + \
///                             p_f \odot c_{t-1} + b_f))
///
/// Block Input
///     .. math::
///         \boldsymbol{z_t} = \
///             g(\mathrm{clip}(W_z \boldsymbol{x_t} + \
///                             R_z \boldsymbol{y_{t-1}} + b_z))
///
/// Cell Memory State
///     .. math::
///         \boldsymbol{c_t} = \
///             \boldsymbol{c_{t-1}} \odot \boldsymbol{f_t} + \
///             \boldsymbol{i_t} \odot \boldsymbol{z_t}
///
/// Output Gate
///     .. math::
///         \boldsymbol{o_t} = \
///             f(\mathrm{clip}(W_o \boldsymbol{x_t} + \
///                             R_o \boldsymbol{y_{t-1}} + \
///                             p_o \odot c_t + b_o))
///
/// Output
///     .. math::
///         \boldsymbol{y_t} = \
///             h(\boldsymbol{c_t}) \odot \boldsymbol{o_t}
///
/// - ``W_i``, ``W_f``, ``W_z``, ``W_o`` are 2-dimensional input weight matrices
///   (``[outputVectorSize, inputVectorSize]``, row-major)
/// - ``R_i``, ``R_f``, ``R_z``, ``R_o`` are 2-dimensional recursion matrices
///   (``[outputVectorSize, outputVectorSize]``, row-major)
/// - ``b_i``, ``b_f``, ``b_z``, ``b_o`` are 1-dimensional bias vectors
///   (``[outputVectorSize]``)
/// - ``p_``, ``p_f``, ``p_o`` are 1-dimensional peephole vectors
///   (``[outputVectorSize]``)
/// - ``f()``, ``g()``, ``h()`` are activations
/// - ``clip()`` is a function that constrains values between ``[-50.0, 50.0]``
/// - ``⊙`` denotes the elementwise product of matrices
public struct CoreML_Specification_LSTMParams: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".LSTMParams"

  ///*
  /// If true, output is a sequence, containing outputs at all time steps.
  /// If false, output is just the result after final state update.
  public var sequenceOutput: Bool = false

  ///*
  /// If false, no biases (``b_i``, ``b_f``, ``b_z``, ``b_o``) are added.
  public var hasBiasVectors_p: Bool = false

  ///*
  /// If true, a vector of ``1`` values is added to ``b_f``.
  public var forgetBias: Bool = false

  ///*
  /// If true, peephole vectors are included.
  public var hasPeepholeVectors_p: Bool = false

  ///*
  /// If the coupled Input and Forget flag is on, the behaviour of
  /// ``c_t`` is changed to the following (i.e. forget gate is not used):
  ///
  /// .. math::
  ///     \boldsymbol{c_t} = \
  ///         \boldsymbol{c_{t-1}} \odot (1 - \boldsymbol{i_t}) + \
  ///         \boldsymbol{i_t} \odot \boldsymbol{z_t}
  public var coupledInputAndForgetGate: Bool = false

  ///*
  /// Places a limit on the maximum and minimum values of ``c_t``.
  /// c_t = min(c_t, cellClipThreshold)
  /// c_t = max(c_t, -cellClipThreshold)
  /// If 0, it is set to its default value = 50.0.
  public var cellClipThreshold: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 10: try decoder.decodeSingularBoolField(value: &self.sequenceOutput)
      case 20: try decoder.decodeSingularBoolField(value: &self.hasBiasVectors_p)
      case 30: try decoder.decodeSingularBoolField(value: &self.forgetBias)
      case 40: try decoder.decodeSingularBoolField(value: &self.hasPeepholeVectors_p)
      case 50: try decoder.decodeSingularBoolField(value: &self.coupledInputAndForgetGate)
      case 60: try decoder.decodeSingularFloatField(value: &self.cellClipThreshold)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sequenceOutput != false {
      try visitor.visitSingularBoolField(value: self.sequenceOutput, fieldNumber: 10)
    }
    if self.hasBiasVectors_p != false {
      try visitor.visitSingularBoolField(value: self.hasBiasVectors_p, fieldNumber: 20)
    }
    if self.forgetBias != false {
      try visitor.visitSingularBoolField(value: self.forgetBias, fieldNumber: 30)
    }
    if self.hasPeepholeVectors_p != false {
      try visitor.visitSingularBoolField(value: self.hasPeepholeVectors_p, fieldNumber: 40)
    }
    if self.coupledInputAndForgetGate != false {
      try visitor.visitSingularBoolField(value: self.coupledInputAndForgetGate, fieldNumber: 50)
    }
    if self.cellClipThreshold != 0 {
      try visitor.visitSingularFloatField(value: self.cellClipThreshold, fieldNumber: 60)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// Weights for long short-term memory (LSTM) layers
public struct CoreML_Specification_LSTMWeightParams: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".LSTMWeightParams"

  //// Weight Matrix W_i.
  public var inputGateWeightMatrix: CoreML_Specification_WeightParams {
    get {return _storage._inputGateWeightMatrix ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._inputGateWeightMatrix = newValue}
  }
  /// Returns true if `inputGateWeightMatrix` has been explicitly set.
  public var hasInputGateWeightMatrix: Bool {return _storage._inputGateWeightMatrix != nil}
  /// Clears the value of `inputGateWeightMatrix`. Subsequent reads from it will return its default value.
  public mutating func clearInputGateWeightMatrix() {_storage._inputGateWeightMatrix = nil}

  //// Weight Matrix W_f.
  public var forgetGateWeightMatrix: CoreML_Specification_WeightParams {
    get {return _storage._forgetGateWeightMatrix ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._forgetGateWeightMatrix = newValue}
  }
  /// Returns true if `forgetGateWeightMatrix` has been explicitly set.
  public var hasForgetGateWeightMatrix: Bool {return _storage._forgetGateWeightMatrix != nil}
  /// Clears the value of `forgetGateWeightMatrix`. Subsequent reads from it will return its default value.
  public mutating func clearForgetGateWeightMatrix() {_storage._forgetGateWeightMatrix = nil}

  //// Weight Matrix W_z.
  public var blockInputWeightMatrix: CoreML_Specification_WeightParams {
    get {return _storage._blockInputWeightMatrix ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._blockInputWeightMatrix = newValue}
  }
  /// Returns true if `blockInputWeightMatrix` has been explicitly set.
  public var hasBlockInputWeightMatrix: Bool {return _storage._blockInputWeightMatrix != nil}
  /// Clears the value of `blockInputWeightMatrix`. Subsequent reads from it will return its default value.
  public mutating func clearBlockInputWeightMatrix() {_storage._blockInputWeightMatrix = nil}

  //// Weight Matrix W_o.
  public var outputGateWeightMatrix: CoreML_Specification_WeightParams {
    get {return _storage._outputGateWeightMatrix ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._outputGateWeightMatrix = newValue}
  }
  /// Returns true if `outputGateWeightMatrix` has been explicitly set.
  public var hasOutputGateWeightMatrix: Bool {return _storage._outputGateWeightMatrix != nil}
  /// Clears the value of `outputGateWeightMatrix`. Subsequent reads from it will return its default value.
  public mutating func clearOutputGateWeightMatrix() {_storage._outputGateWeightMatrix = nil}

  //// Recursion Weight Matrix R_i.
  public var inputGateRecursionMatrix: CoreML_Specification_WeightParams {
    get {return _storage._inputGateRecursionMatrix ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._inputGateRecursionMatrix = newValue}
  }
  /// Returns true if `inputGateRecursionMatrix` has been explicitly set.
  public var hasInputGateRecursionMatrix: Bool {return _storage._inputGateRecursionMatrix != nil}
  /// Clears the value of `inputGateRecursionMatrix`. Subsequent reads from it will return its default value.
  public mutating func clearInputGateRecursionMatrix() {_storage._inputGateRecursionMatrix = nil}

  //// Recursion Weight Matrix R_f.
  public var forgetGateRecursionMatrix: CoreML_Specification_WeightParams {
    get {return _storage._forgetGateRecursionMatrix ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._forgetGateRecursionMatrix = newValue}
  }
  /// Returns true if `forgetGateRecursionMatrix` has been explicitly set.
  public var hasForgetGateRecursionMatrix: Bool {return _storage._forgetGateRecursionMatrix != nil}
  /// Clears the value of `forgetGateRecursionMatrix`. Subsequent reads from it will return its default value.
  public mutating func clearForgetGateRecursionMatrix() {_storage._forgetGateRecursionMatrix = nil}

  //// Recursion Weight Matrix R_z.
  public var blockInputRecursionMatrix: CoreML_Specification_WeightParams {
    get {return _storage._blockInputRecursionMatrix ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._blockInputRecursionMatrix = newValue}
  }
  /// Returns true if `blockInputRecursionMatrix` has been explicitly set.
  public var hasBlockInputRecursionMatrix: Bool {return _storage._blockInputRecursionMatrix != nil}
  /// Clears the value of `blockInputRecursionMatrix`. Subsequent reads from it will return its default value.
  public mutating func clearBlockInputRecursionMatrix() {_storage._blockInputRecursionMatrix = nil}

  //// Recursion Weight Matrix R_o.
  public var outputGateRecursionMatrix: CoreML_Specification_WeightParams {
    get {return _storage._outputGateRecursionMatrix ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._outputGateRecursionMatrix = newValue}
  }
  /// Returns true if `outputGateRecursionMatrix` has been explicitly set.
  public var hasOutputGateRecursionMatrix: Bool {return _storage._outputGateRecursionMatrix != nil}
  /// Clears the value of `outputGateRecursionMatrix`. Subsequent reads from it will return its default value.
  public mutating func clearOutputGateRecursionMatrix() {_storage._outputGateRecursionMatrix = nil}

  ///biases:
  public var inputGateBiasVector: CoreML_Specification_WeightParams {
    get {return _storage._inputGateBiasVector ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._inputGateBiasVector = newValue}
  }
  /// Returns true if `inputGateBiasVector` has been explicitly set.
  public var hasInputGateBiasVector: Bool {return _storage._inputGateBiasVector != nil}
  /// Clears the value of `inputGateBiasVector`. Subsequent reads from it will return its default value.
  public mutating func clearInputGateBiasVector() {_storage._inputGateBiasVector = nil}

  //// Bias vector b_f.
  public var forgetGateBiasVector: CoreML_Specification_WeightParams {
    get {return _storage._forgetGateBiasVector ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._forgetGateBiasVector = newValue}
  }
  /// Returns true if `forgetGateBiasVector` has been explicitly set.
  public var hasForgetGateBiasVector: Bool {return _storage._forgetGateBiasVector != nil}
  /// Clears the value of `forgetGateBiasVector`. Subsequent reads from it will return its default value.
  public mutating func clearForgetGateBiasVector() {_storage._forgetGateBiasVector = nil}

  //// Bias vector b_z.
  public var blockInputBiasVector: CoreML_Specification_WeightParams {
    get {return _storage._blockInputBiasVector ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._blockInputBiasVector = newValue}
  }
  /// Returns true if `blockInputBiasVector` has been explicitly set.
  public var hasBlockInputBiasVector: Bool {return _storage._blockInputBiasVector != nil}
  /// Clears the value of `blockInputBiasVector`. Subsequent reads from it will return its default value.
  public mutating func clearBlockInputBiasVector() {_storage._blockInputBiasVector = nil}

  //// Bias vector b_o.
  public var outputGateBiasVector: CoreML_Specification_WeightParams {
    get {return _storage._outputGateBiasVector ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._outputGateBiasVector = newValue}
  }
  /// Returns true if `outputGateBiasVector` has been explicitly set.
  public var hasOutputGateBiasVector: Bool {return _storage._outputGateBiasVector != nil}
  /// Clears the value of `outputGateBiasVector`. Subsequent reads from it will return its default value.
  public mutating func clearOutputGateBiasVector() {_storage._outputGateBiasVector = nil}

  ///peepholes:
  public var inputGatePeepholeVector: CoreML_Specification_WeightParams {
    get {return _storage._inputGatePeepholeVector ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._inputGatePeepholeVector = newValue}
  }
  /// Returns true if `inputGatePeepholeVector` has been explicitly set.
  public var hasInputGatePeepholeVector: Bool {return _storage._inputGatePeepholeVector != nil}
  /// Clears the value of `inputGatePeepholeVector`. Subsequent reads from it will return its default value.
  public mutating func clearInputGatePeepholeVector() {_storage._inputGatePeepholeVector = nil}

  //// Peephole vector p_f.
  public var forgetGatePeepholeVector: CoreML_Specification_WeightParams {
    get {return _storage._forgetGatePeepholeVector ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._forgetGatePeepholeVector = newValue}
  }
  /// Returns true if `forgetGatePeepholeVector` has been explicitly set.
  public var hasForgetGatePeepholeVector: Bool {return _storage._forgetGatePeepholeVector != nil}
  /// Clears the value of `forgetGatePeepholeVector`. Subsequent reads from it will return its default value.
  public mutating func clearForgetGatePeepholeVector() {_storage._forgetGatePeepholeVector = nil}

  //// Peephole vector p_o.
  public var outputGatePeepholeVector: CoreML_Specification_WeightParams {
    get {return _storage._outputGatePeepholeVector ?? CoreML_Specification_WeightParams()}
    set {_uniqueStorage()._outputGatePeepholeVector = newValue}
  }
  /// Returns true if `outputGatePeepholeVector` has been explicitly set.
  public var hasOutputGatePeepholeVector: Bool {return _storage._outputGatePeepholeVector != nil}
  /// Clears the value of `outputGatePeepholeVector`. Subsequent reads from it will return its default value.
  public mutating func clearOutputGatePeepholeVector() {_storage._outputGatePeepholeVector = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._inputGateWeightMatrix)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._forgetGateWeightMatrix)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._blockInputWeightMatrix)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._outputGateWeightMatrix)
        case 20: try decoder.decodeSingularMessageField(value: &_storage._inputGateRecursionMatrix)
        case 21: try decoder.decodeSingularMessageField(value: &_storage._forgetGateRecursionMatrix)
        case 22: try decoder.decodeSingularMessageField(value: &_storage._blockInputRecursionMatrix)
        case 23: try decoder.decodeSingularMessageField(value: &_storage._outputGateRecursionMatrix)
        case 40: try decoder.decodeSingularMessageField(value: &_storage._inputGateBiasVector)
        case 41: try decoder.decodeSingularMessageField(value: &_storage._forgetGateBiasVector)
        case 42: try decoder.decodeSingularMessageField(value: &_storage._blockInputBiasVector)
        case 43: try decoder.decodeSingularMessageField(value: &_storage._outputGateBiasVector)
        case 60: try decoder.decodeSingularMessageField(value: &_storage._inputGatePeepholeVector)
        case 61: try decoder.decodeSingularMessageField(value: &_storage._forgetGatePeepholeVector)
        case 62: try decoder.decodeSingularMessageField(value: &_storage._outputGatePeepholeVector)
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._inputGateWeightMatrix {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._forgetGateWeightMatrix {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._blockInputWeightMatrix {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._outputGateWeightMatrix {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._inputGateRecursionMatrix {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      }
      if let v = _storage._forgetGateRecursionMatrix {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      }
      if let v = _storage._blockInputRecursionMatrix {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      }
      if let v = _storage._outputGateRecursionMatrix {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      }
      if let v = _storage._inputGateBiasVector {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 40)
      }
      if let v = _storage._forgetGateBiasVector {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 41)
      }
      if let v = _storage._blockInputBiasVector {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 42)
      }
      if let v = _storage._outputGateBiasVector {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 43)
      }
      if let v = _storage._inputGatePeepholeVector {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 60)
      }
      if let v = _storage._forgetGatePeepholeVector {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 61)
      }
      if let v = _storage._outputGatePeepholeVector {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 62)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// A unidirectional long short-term memory (LSTM) layer.
/// ::
/// 		(y_t, c_t) = UniDirectionalLSTMLayer(x_t, y_{t-1}, c_{t-1})
///
/// Input
///    A sequence of vectors of size ``inputVectorSize``
///    with shape ``[Seq, inputVectorSize]``.
/// Output
///    A vector of size ``outputVectorSize``. It is either the final output or a sequence of outputs at all time steps.  
/// - Output Shape: ``[1,outputVectorSize]`` , if ``sequenceOutput == false``
/// - Output Shape: ``[Seq,outputVectorSize]`` , if ``sequenceOutput == true``
public struct CoreML_Specification_UniDirectionalLSTMLayerParams: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".UniDirectionalLSTMLayerParams"

  //// Size of the input vectors.
  public var inputVectorSize: UInt64 {
    get {return _storage._inputVectorSize}
    set {_uniqueStorage()._inputVectorSize = newValue}
  }

  //// Size of the output vectors.
  public var outputVectorSize: UInt64 {
    get {return _storage._outputVectorSize}
    set {_uniqueStorage()._outputVectorSize = newValue}
  }

  ///*
  /// 3 element array representing activations [f(),g(),h()] in that order.
  /// Typical values used = [sigmoid, tanh, tanh].
  /// Activations supported are Linear, Sigmoid, Tanh, ReLU, Scaled Tanh (alpha = 1.71, beta = 2/3), Hard sigmoid (alpha = 0.2, beta = 0.5)
  public var activations: [CoreML_Specification_ActivationParams] {
    get {return _storage._activations}
    set {_uniqueStorage()._activations = newValue}
  }

  public var params: CoreML_Specification_LSTMParams {
    get {return _storage._params ?? CoreML_Specification_LSTMParams()}
    set {_uniqueStorage()._params = newValue}
  }
  /// Returns true if `params` has been explicitly set.
  public var hasParams: Bool {return _storage._params != nil}
  /// Clears the value of `params`. Subsequent reads from it will return its default value.
  public mutating func clearParams() {_storage._params = nil}

  //// Weights, biases and peepholes.
  public var weightParams: CoreML_Specification_LSTMWeightParams {
    get {return _storage._weightParams ?? CoreML_Specification_LSTMWeightParams()}
    set {_uniqueStorage()._weightParams = newValue}
  }
  /// Returns true if `weightParams` has been explicitly set.
  public var hasWeightParams: Bool {return _storage._weightParams != nil}
  /// Clears the value of `weightParams`. Subsequent reads from it will return its default value.
  public mutating func clearWeightParams() {_storage._weightParams = nil}

  //// If true, then the node processes the input sequence from right to left
  public var reverseInput: Bool {
    get {return _storage._reverseInput}
    set {_uniqueStorage()._reverseInput = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt64Field(value: &_storage._inputVectorSize)
        case 2: try decoder.decodeSingularUInt64Field(value: &_storage._outputVectorSize)
        case 10: try decoder.decodeRepeatedMessageField(value: &_storage._activations)
        case 15: try decoder.decodeSingularMessageField(value: &_storage._params)
        case 20: try decoder.decodeSingularMessageField(value: &_storage._weightParams)
        case 100: try decoder.decodeSingularBoolField(value: &_storage._reverseInput)
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._inputVectorSize != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._inputVectorSize, fieldNumber: 1)
      }
      if _storage._outputVectorSize != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._outputVectorSize, fieldNumber: 2)
      }
      if !_storage._activations.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._activations, fieldNumber: 10)
      }
      if let v = _storage._params {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
      if let v = _storage._weightParams {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      }
      if _storage._reverseInput != false {
        try visitor.visitSingularBoolField(value: _storage._reverseInput, fieldNumber: 100)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// Bidirectional long short-term memory (LSTM) layer
/// ::
/// 		(y_t, c_t, y_t_reverse, c_t_reverse) = BiDirectionalLSTMLayer(x_t, y_{t-1}, c_{t-1}, y_{t-1}_reverse, c_{t-1}_reverse)
///
/// Input
///    A sequence of vectors of size ``inputVectorSize``
///    with shape ``[Seq, inputVectorSize]``.
/// Output
///    A vector of size ``2 * outputVectorSize``. It is either the final output or a sequence of outputs at all time steps.  
/// - Output Shape: ``[1, 2 * outputVectorSize]`` , if ``sequenceOutput == false``
/// - Output Shape: ``[Seq, 2 * outputVectorSize]`` , if ``sequenceOutput == true``
///
/// The first LSTM operates on the input sequence in the forward direction.
/// The second LSTM operates on the input sequence in the reverse direction.
///
/// Example: given the input sequence ``[x_1, x_2, x_3]``,
/// where ``x_i`` are vectors at time index ``i``:
/// 
/// The forward LSTM output is ``[yf_1, yf_2, yf_3]``,
/// 
/// where ``yf_i`` are vectors of size ``outputVectorSize``:
/// 
/// - ``yf_1`` is the output at the end of sequence {``x_1``}
/// - ``yf_2`` is the output at the end of sequence {``x_1``, ``x_2``}
/// - ``yf_3`` is the output at the end of sequence {``x_1``, ``x_2``, ``x_3``}
///
/// The backward LSTM output: ``[yb_1, yb_2, yb_3]``,
///
/// where ``yb_i`` are vectors of size ``outputVectorSize``:
/// 
/// - ``yb_1`` is the output at the end of sequence {``x_3``}
/// - ``yb_2`` is the output at the end of sequence {``x_3``, ``x_2``}
/// - ``yb_3`` is the output at the end of sequence {``x_3``, ``x_2``, ``x_1``}
///
/// Output of the bi-dir layer:
///
/// - if ``sequenceOutput = True`` : { ``[yf_1, yb_3]``,  ``[yf_2, yb_2]``,  ``[yf_3, yb_1]`` }
/// - if ``sequenceOutput = False`` : { ``[yf_3, yb_3]`` }
public struct CoreML_Specification_BiDirectionalLSTMLayerParams: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".BiDirectionalLSTMLayerParams"

  ///*
  /// Size of the input vectors.
  public var inputVectorSize: UInt64 {
    get {return _storage._inputVectorSize}
    set {_uniqueStorage()._inputVectorSize = newValue}
  }

  ///*
  /// Size of the outputs vectors.
  /// It is same for both forward and backward LSTMs.
  public var outputVectorSize: UInt64 {
    get {return _storage._outputVectorSize}
    set {_uniqueStorage()._outputVectorSize = newValue}
  }

  ///*
  /// 3 element array representing activations [f(),g(),h()] in that order.
  /// Typical values used = [sigmoid, tanh, tanh].
  /// Activations supported are Linear, Sigmoid, Tanh, ReLU, Scaled Tanh (alpha = 1.71, beta = 2/3), Hard sigmoid (alpha = 0.2, beta = 0.5)
  public var activationsForwardLstm: [CoreML_Specification_ActivationParams] {
    get {return _storage._activationsForwardLstm}
    set {_uniqueStorage()._activationsForwardLstm = newValue}
  }

  ///*
  /// Currently, backward LSTM activations
  /// must be same as the ones for the forward LSTM.
  public var activationsBackwardLstm: [CoreML_Specification_ActivationParams] {
    get {return _storage._activationsBackwardLstm}
    set {_uniqueStorage()._activationsBackwardLstm = newValue}
  }

  ///*
  /// Common parameters shared by the forward and backward LSTMs.
  public var params: CoreML_Specification_LSTMParams {
    get {return _storage._params ?? CoreML_Specification_LSTMParams()}
    set {_uniqueStorage()._params = newValue}
  }
  /// Returns true if `params` has been explicitly set.
  public var hasParams: Bool {return _storage._params != nil}
  /// Clears the value of `params`. Subsequent reads from it will return its default value.
  public mutating func clearParams() {_storage._params = nil}

  ///*
  /// Weights and biases.
  /// Must be a length 2 message,
  /// for the forward and backward LSTM respectively.
  public var weightParams: [CoreML_Specification_LSTMWeightParams] {
    get {return _storage._weightParams}
    set {_uniqueStorage()._weightParams = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt64Field(value: &_storage._inputVectorSize)
        case 2: try decoder.decodeSingularUInt64Field(value: &_storage._outputVectorSize)
        case 10: try decoder.decodeRepeatedMessageField(value: &_storage._activationsForwardLstm)
        case 11: try decoder.decodeRepeatedMessageField(value: &_storage._activationsBackwardLstm)
        case 15: try decoder.decodeSingularMessageField(value: &_storage._params)
        case 20: try decoder.decodeRepeatedMessageField(value: &_storage._weightParams)
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._inputVectorSize != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._inputVectorSize, fieldNumber: 1)
      }
      if _storage._outputVectorSize != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._outputVectorSize, fieldNumber: 2)
      }
      if !_storage._activationsForwardLstm.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._activationsForwardLstm, fieldNumber: 10)
      }
      if !_storage._activationsBackwardLstm.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._activationsBackwardLstm, fieldNumber: 11)
      }
      if let v = _storage._params {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
      if !_storage._weightParams.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._weightParams, fieldNumber: 20)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// A neural network specialized as a classifier.
public struct CoreML_Specification_NeuralNetworkClassifier: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".NeuralNetworkClassifier"

  public var layers: [CoreML_Specification_NeuralNetworkLayer] {
    get {return _storage._layers}
    set {_uniqueStorage()._layers = newValue}
  }

  public var preprocessing: [CoreML_Specification_NeuralNetworkPreprocessing] {
    get {return _storage._preprocessing}
    set {_uniqueStorage()._preprocessing = newValue}
  }

  ///*
  /// Mapping from indexed vector of probabilities to class label
  public var classLabels: OneOf_ClassLabels? {
    get {return _storage._classLabels}
    set {_uniqueStorage()._classLabels = newValue}
  }

  public var stringClassLabels: CoreML_Specification_StringVector {
    get {
      if case .stringClassLabels(let v)? = _storage._classLabels {return v}
      return CoreML_Specification_StringVector()
    }
    set {_uniqueStorage()._classLabels = .stringClassLabels(newValue)}
  }

  public var int64ClassLabels: CoreML_Specification_Int64Vector {
    get {
      if case .int64ClassLabels(let v)? = _storage._classLabels {return v}
      return CoreML_Specification_Int64Vector()
    }
    set {_uniqueStorage()._classLabels = .int64ClassLabels(newValue)}
  }

  ///*
  /// The name of the output blob which will be used as the predicted
  /// probabilities of each class label.
  public var labelProbabilityLayerName: String {
    get {return _storage._labelProbabilityLayerName}
    set {_uniqueStorage()._labelProbabilityLayerName = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  ///*
  /// Mapping from indexed vector of probabilities to class label
  public enum OneOf_ClassLabels: Equatable {
    case stringClassLabels(CoreML_Specification_StringVector)
    case int64ClassLabels(CoreML_Specification_Int64Vector)

    public static func ==(lhs: CoreML_Specification_NeuralNetworkClassifier.OneOf_ClassLabels, rhs: CoreML_Specification_NeuralNetworkClassifier.OneOf_ClassLabels) -> Bool {
      switch (lhs, rhs) {
      case (.stringClassLabels(let l), .stringClassLabels(let r)): return l == r
      case (.int64ClassLabels(let l), .int64ClassLabels(let r)): return l == r
      default: return false
      }
    }
  }

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedMessageField(value: &_storage._layers)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._preprocessing)
        case 100:
          var v: CoreML_Specification_StringVector?
          if let current = _storage._classLabels {
            try decoder.handleConflictingOneOf()
            if case .stringClassLabels(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._classLabels = .stringClassLabels(v)}
        case 101:
          var v: CoreML_Specification_Int64Vector?
          if let current = _storage._classLabels {
            try decoder.handleConflictingOneOf()
            if case .int64ClassLabels(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._classLabels = .int64ClassLabels(v)}
        case 200: try decoder.decodeSingularStringField(value: &_storage._labelProbabilityLayerName)
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._layers.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._layers, fieldNumber: 1)
      }
      if !_storage._preprocessing.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._preprocessing, fieldNumber: 2)
      }
      switch _storage._classLabels {
      case .stringClassLabels(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 100)
      case .int64ClassLabels(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
      case nil: break
      }
      if !_storage._labelProbabilityLayerName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._labelProbabilityLayerName, fieldNumber: 200)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// A neural network specialized as a regressor.
public struct CoreML_Specification_NeuralNetworkRegressor: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".NeuralNetworkRegressor"

  public var layers: [CoreML_Specification_NeuralNetworkLayer] = []

  public var preprocessing: [CoreML_Specification_NeuralNetworkPreprocessing] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.layers)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.preprocessing)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.layers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.layers, fieldNumber: 1)
    }
    if !self.preprocessing.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.preprocessing, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "CoreML.Specification"

extension CoreML_Specification_NeuralNetwork: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "layers"),
    2: .same(proto: "preprocessing"),
  ]

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_NeuralNetwork) -> Bool {
    if self.layers != other.layers {return false}
    if self.preprocessing != other.preprocessing {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_NeuralNetworkImageScaler: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    10: .same(proto: "channelScale"),
    20: .same(proto: "blueBias"),
    21: .same(proto: "greenBias"),
    22: .same(proto: "redBias"),
    30: .same(proto: "grayBias"),
  ]

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_NeuralNetworkImageScaler) -> Bool {
    if self.channelScale != other.channelScale {return false}
    if self.blueBias != other.blueBias {return false}
    if self.greenBias != other.greenBias {return false}
    if self.redBias != other.redBias {return false}
    if self.grayBias != other.grayBias {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_NeuralNetworkMeanImage: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "meanImage"),
  ]

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_NeuralNetworkMeanImage) -> Bool {
    if self.meanImage != other.meanImage {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_NeuralNetworkPreprocessing: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "featureName"),
    10: .same(proto: "scaler"),
    11: .same(proto: "meanImage"),
  ]

  fileprivate class _StorageClass {
    var _featureName: String = String()
    var _preprocessor: CoreML_Specification_NeuralNetworkPreprocessing.OneOf_Preprocessor?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _featureName = source._featureName
      _preprocessor = source._preprocessor
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_NeuralNetworkPreprocessing) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._featureName != other_storage._featureName {return false}
        if _storage._preprocessor != other_storage._preprocessor {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_ActivationReLU: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_ActivationReLU) -> Bool {
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_ActivationLeakyReLU: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "alpha"),
  ]

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_ActivationLeakyReLU) -> Bool {
    if self.alpha != other.alpha {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_ActivationTanh: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_ActivationTanh) -> Bool {
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_ActivationScaledTanh: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "alpha"),
    2: .same(proto: "beta"),
  ]

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_ActivationScaledTanh) -> Bool {
    if self.alpha != other.alpha {return false}
    if self.beta != other.beta {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_ActivationSigmoid: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_ActivationSigmoid) -> Bool {
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_ActivationLinear: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "alpha"),
    2: .same(proto: "beta"),
  ]

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_ActivationLinear) -> Bool {
    if self.alpha != other.alpha {return false}
    if self.beta != other.beta {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_ActivationSigmoidHard: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "alpha"),
    2: .same(proto: "beta"),
  ]

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_ActivationSigmoidHard) -> Bool {
    if self.alpha != other.alpha {return false}
    if self.beta != other.beta {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_ActivationPReLU: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "alpha"),
  ]

  fileprivate class _StorageClass {
    var _alpha: CoreML_Specification_WeightParams? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _alpha = source._alpha
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_ActivationPReLU) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._alpha != other_storage._alpha {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_ActivationELU: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "alpha"),
  ]

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_ActivationELU) -> Bool {
    if self.alpha != other.alpha {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_ActivationThresholdedReLU: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "alpha"),
  ]

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_ActivationThresholdedReLU) -> Bool {
    if self.alpha != other.alpha {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_ActivationSoftsign: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_ActivationSoftsign) -> Bool {
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_ActivationSoftplus: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_ActivationSoftplus) -> Bool {
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_ActivationParametricSoftplus: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "alpha"),
    2: .same(proto: "beta"),
  ]

  fileprivate class _StorageClass {
    var _alpha: CoreML_Specification_WeightParams? = nil
    var _beta: CoreML_Specification_WeightParams? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _alpha = source._alpha
      _beta = source._beta
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_ActivationParametricSoftplus) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._alpha != other_storage._alpha {return false}
        if _storage._beta != other_storage._beta {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_ActivationParams: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    5: .same(proto: "linear"),
    10: .same(proto: "ReLU"),
    15: .same(proto: "leakyReLU"),
    20: .same(proto: "thresholdedReLU"),
    25: .same(proto: "PReLU"),
    30: .same(proto: "tanh"),
    31: .same(proto: "scaledTanh"),
    40: .same(proto: "sigmoid"),
    41: .same(proto: "sigmoidHard"),
    50: .same(proto: "ELU"),
    60: .same(proto: "softsign"),
    70: .same(proto: "softplus"),
    71: .same(proto: "parametricSoftplus"),
  ]

  fileprivate class _StorageClass {
    var _nonlinearityType: CoreML_Specification_ActivationParams.OneOf_NonlinearityType?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _nonlinearityType = source._nonlinearityType
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_ActivationParams) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._nonlinearityType != other_storage._nonlinearityType {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_NeuralNetworkLayer: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "input"),
    3: .same(proto: "output"),
    100: .same(proto: "convolution"),
    120: .same(proto: "pooling"),
    130: .same(proto: "activation"),
    140: .same(proto: "innerProduct"),
    150: .same(proto: "embedding"),
    160: .same(proto: "batchnorm"),
    165: .same(proto: "mvn"),
    170: .same(proto: "l2normalize"),
    175: .same(proto: "softmax"),
    180: .same(proto: "lrn"),
    190: .same(proto: "crop"),
    200: .same(proto: "padding"),
    210: .same(proto: "upsample"),
    220: .same(proto: "unary"),
    230: .same(proto: "add"),
    231: .same(proto: "multiply"),
    240: .same(proto: "average"),
    245: .same(proto: "scale"),
    250: .same(proto: "bias"),
    260: .same(proto: "max"),
    261: .same(proto: "min"),
    270: .same(proto: "dot"),
    280: .same(proto: "reduce"),
    290: .same(proto: "loadConstant"),
    300: .same(proto: "reshape"),
    301: .same(proto: "flatten"),
    310: .same(proto: "permute"),
    320: .same(proto: "concat"),
    330: .same(proto: "split"),
    340: .same(proto: "sequenceRepeat"),
    345: .same(proto: "reorganizeData"),
    350: .same(proto: "slice"),
    400: .same(proto: "simpleRecurrent"),
    410: .same(proto: "gru"),
    420: .same(proto: "uniDirectionalLSTM"),
    430: .same(proto: "biDirectionalLSTM"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _input: [String] = []
    var _output: [String] = []
    var _layer: CoreML_Specification_NeuralNetworkLayer.OneOf_Layer?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _input = source._input
      _output = source._output
      _layer = source._layer
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_NeuralNetworkLayer) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._name != other_storage._name {return false}
        if _storage._input != other_storage._input {return false}
        if _storage._output != other_storage._output {return false}
        if _storage._layer != other_storage._layer {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_BorderAmounts: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    10: .same(proto: "borderAmounts"),
  ]

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_BorderAmounts) -> Bool {
    if self.borderAmounts != other.borderAmounts {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_BorderAmounts.EdgeSizes: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "startEdgeSize"),
    2: .same(proto: "endEdgeSize"),
  ]

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_BorderAmounts.EdgeSizes) -> Bool {
    if self.startEdgeSize != other.startEdgeSize {return false}
    if self.endEdgeSize != other.endEdgeSize {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_ValidPadding: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "paddingAmounts"),
  ]

  fileprivate class _StorageClass {
    var _paddingAmounts: CoreML_Specification_BorderAmounts? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _paddingAmounts = source._paddingAmounts
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_ValidPadding) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._paddingAmounts != other_storage._paddingAmounts {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_SamePadding: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "asymmetryMode"),
  ]

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_SamePadding) -> Bool {
    if self.asymmetryMode != other.asymmetryMode {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_SamePadding.SamePaddingMode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "BOTTOM_RIGHT_HEAVY"),
    1: .same(proto: "TOP_LEFT_HEAVY"),
  ]
}

extension CoreML_Specification_WeightParams: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "floatValue"),
  ]

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_WeightParams) -> Bool {
    if self.floatValue != other.floatValue {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_ConvolutionLayerParams: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "outputChannels"),
    2: .same(proto: "kernelChannels"),
    10: .same(proto: "nGroups"),
    20: .same(proto: "kernelSize"),
    30: .same(proto: "stride"),
    40: .same(proto: "dilationFactor"),
    50: .same(proto: "valid"),
    51: .same(proto: "same"),
    60: .same(proto: "isDeconvolution"),
    70: .same(proto: "hasBias"),
    90: .same(proto: "weights"),
    91: .same(proto: "bias"),
    100: .same(proto: "outputShape"),
  ]

  fileprivate class _StorageClass {
    var _outputChannels: UInt64 = 0
    var _kernelChannels: UInt64 = 0
    var _nGroups: UInt64 = 0
    var _kernelSize: [UInt64] = []
    var _stride: [UInt64] = []
    var _dilationFactor: [UInt64] = []
    var _convolutionPaddingType: CoreML_Specification_ConvolutionLayerParams.OneOf_ConvolutionPaddingType?
    var _isDeconvolution: Bool = false
    var _hasBias_p: Bool = false
    var _weights: CoreML_Specification_WeightParams? = nil
    var _bias: CoreML_Specification_WeightParams? = nil
    var _outputShape: [UInt64] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _outputChannels = source._outputChannels
      _kernelChannels = source._kernelChannels
      _nGroups = source._nGroups
      _kernelSize = source._kernelSize
      _stride = source._stride
      _dilationFactor = source._dilationFactor
      _convolutionPaddingType = source._convolutionPaddingType
      _isDeconvolution = source._isDeconvolution
      _hasBias_p = source._hasBias_p
      _weights = source._weights
      _bias = source._bias
      _outputShape = source._outputShape
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_ConvolutionLayerParams) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._outputChannels != other_storage._outputChannels {return false}
        if _storage._kernelChannels != other_storage._kernelChannels {return false}
        if _storage._nGroups != other_storage._nGroups {return false}
        if _storage._kernelSize != other_storage._kernelSize {return false}
        if _storage._stride != other_storage._stride {return false}
        if _storage._dilationFactor != other_storage._dilationFactor {return false}
        if _storage._convolutionPaddingType != other_storage._convolutionPaddingType {return false}
        if _storage._isDeconvolution != other_storage._isDeconvolution {return false}
        if _storage._hasBias_p != other_storage._hasBias_p {return false}
        if _storage._weights != other_storage._weights {return false}
        if _storage._bias != other_storage._bias {return false}
        if _storage._outputShape != other_storage._outputShape {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_InnerProductLayerParams: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "inputChannels"),
    2: .same(proto: "outputChannels"),
    10: .same(proto: "hasBias"),
    20: .same(proto: "weights"),
    21: .same(proto: "bias"),
  ]

  fileprivate class _StorageClass {
    var _inputChannels: UInt64 = 0
    var _outputChannels: UInt64 = 0
    var _hasBias_p: Bool = false
    var _weights: CoreML_Specification_WeightParams? = nil
    var _bias: CoreML_Specification_WeightParams? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _inputChannels = source._inputChannels
      _outputChannels = source._outputChannels
      _hasBias_p = source._hasBias_p
      _weights = source._weights
      _bias = source._bias
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_InnerProductLayerParams) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._inputChannels != other_storage._inputChannels {return false}
        if _storage._outputChannels != other_storage._outputChannels {return false}
        if _storage._hasBias_p != other_storage._hasBias_p {return false}
        if _storage._weights != other_storage._weights {return false}
        if _storage._bias != other_storage._bias {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_EmbeddingLayerParams: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "inputDim"),
    2: .same(proto: "outputChannels"),
    10: .same(proto: "hasBias"),
    20: .same(proto: "weights"),
    21: .same(proto: "bias"),
  ]

  fileprivate class _StorageClass {
    var _inputDim: UInt64 = 0
    var _outputChannels: UInt64 = 0
    var _hasBias_p: Bool = false
    var _weights: CoreML_Specification_WeightParams? = nil
    var _bias: CoreML_Specification_WeightParams? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _inputDim = source._inputDim
      _outputChannels = source._outputChannels
      _hasBias_p = source._hasBias_p
      _weights = source._weights
      _bias = source._bias
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_EmbeddingLayerParams) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._inputDim != other_storage._inputDim {return false}
        if _storage._outputChannels != other_storage._outputChannels {return false}
        if _storage._hasBias_p != other_storage._hasBias_p {return false}
        if _storage._weights != other_storage._weights {return false}
        if _storage._bias != other_storage._bias {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_BatchnormLayerParams: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channels"),
    5: .same(proto: "computeMeanVar"),
    6: .same(proto: "instanceNormalization"),
    10: .same(proto: "epsilon"),
    15: .same(proto: "gamma"),
    16: .same(proto: "beta"),
    17: .same(proto: "mean"),
    18: .same(proto: "variance"),
  ]

  fileprivate class _StorageClass {
    var _channels: UInt64 = 0
    var _computeMeanVar: Bool = false
    var _instanceNormalization: Bool = false
    var _epsilon: Float = 0
    var _gamma: CoreML_Specification_WeightParams? = nil
    var _beta: CoreML_Specification_WeightParams? = nil
    var _mean: CoreML_Specification_WeightParams? = nil
    var _variance: CoreML_Specification_WeightParams? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _channels = source._channels
      _computeMeanVar = source._computeMeanVar
      _instanceNormalization = source._instanceNormalization
      _epsilon = source._epsilon
      _gamma = source._gamma
      _beta = source._beta
      _mean = source._mean
      _variance = source._variance
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_BatchnormLayerParams) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._channels != other_storage._channels {return false}
        if _storage._computeMeanVar != other_storage._computeMeanVar {return false}
        if _storage._instanceNormalization != other_storage._instanceNormalization {return false}
        if _storage._epsilon != other_storage._epsilon {return false}
        if _storage._gamma != other_storage._gamma {return false}
        if _storage._beta != other_storage._beta {return false}
        if _storage._mean != other_storage._mean {return false}
        if _storage._variance != other_storage._variance {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_PoolingLayerParams: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    10: .same(proto: "kernelSize"),
    20: .same(proto: "stride"),
    30: .same(proto: "valid"),
    31: .same(proto: "same"),
    32: .same(proto: "includeLastPixel"),
    50: .same(proto: "avgPoolExcludePadding"),
    60: .same(proto: "globalPooling"),
  ]

  fileprivate class _StorageClass {
    var _type: CoreML_Specification_PoolingLayerParams.PoolingType = .max
    var _kernelSize: [UInt64] = []
    var _stride: [UInt64] = []
    var _poolingPaddingType: CoreML_Specification_PoolingLayerParams.OneOf_PoolingPaddingType?
    var _avgPoolExcludePadding: Bool = false
    var _globalPooling: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _kernelSize = source._kernelSize
      _stride = source._stride
      _poolingPaddingType = source._poolingPaddingType
      _avgPoolExcludePadding = source._avgPoolExcludePadding
      _globalPooling = source._globalPooling
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_PoolingLayerParams) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._type != other_storage._type {return false}
        if _storage._kernelSize != other_storage._kernelSize {return false}
        if _storage._stride != other_storage._stride {return false}
        if _storage._poolingPaddingType != other_storage._poolingPaddingType {return false}
        if _storage._avgPoolExcludePadding != other_storage._avgPoolExcludePadding {return false}
        if _storage._globalPooling != other_storage._globalPooling {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_PoolingLayerParams.PoolingType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MAX"),
    1: .same(proto: "AVERAGE"),
    2: .same(proto: "L2"),
  ]
}

extension CoreML_Specification_PoolingLayerParams.ValidCompletePadding: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    10: .same(proto: "paddingAmounts"),
  ]

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_PoolingLayerParams.ValidCompletePadding) -> Bool {
    if self.paddingAmounts != other.paddingAmounts {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_PaddingLayerParams: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "constant"),
    2: .same(proto: "reflection"),
    3: .same(proto: "replication"),
    10: .same(proto: "paddingAmounts"),
  ]

  fileprivate class _StorageClass {
    var _paddingType: CoreML_Specification_PaddingLayerParams.OneOf_PaddingType?
    var _paddingAmounts: CoreML_Specification_BorderAmounts? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _paddingType = source._paddingType
      _paddingAmounts = source._paddingAmounts
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_PaddingLayerParams) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._paddingType != other_storage._paddingType {return false}
        if _storage._paddingAmounts != other_storage._paddingAmounts {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_PaddingLayerParams.PaddingConstant: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_PaddingLayerParams.PaddingConstant) -> Bool {
    if self.value != other.value {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_PaddingLayerParams.PaddingReflection: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_PaddingLayerParams.PaddingReflection) -> Bool {
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_PaddingLayerParams.PaddingReplication: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_PaddingLayerParams.PaddingReplication) -> Bool {
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_ConcatLayerParams: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    100: .same(proto: "sequenceConcat"),
  ]

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_ConcatLayerParams) -> Bool {
    if self.sequenceConcat != other.sequenceConcat {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_LRNLayerParams: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "alpha"),
    2: .same(proto: "beta"),
    3: .same(proto: "localSize"),
    4: .same(proto: "k"),
  ]

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_LRNLayerParams) -> Bool {
    if self.alpha != other.alpha {return false}
    if self.beta != other.beta {return false}
    if self.localSize != other.localSize {return false}
    if self.k != other.k {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_SoftmaxLayerParams: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_SoftmaxLayerParams) -> Bool {
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_SplitLayerParams: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nOutputs"),
  ]

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_SplitLayerParams) -> Bool {
    if self.nOutputs != other.nOutputs {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_AddLayerParams: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "alpha"),
  ]

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_AddLayerParams) -> Bool {
    if self.alpha != other.alpha {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_MultiplyLayerParams: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "alpha"),
  ]

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_MultiplyLayerParams) -> Bool {
    if self.alpha != other.alpha {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_UnaryFunctionLayerParams: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "alpha"),
    3: .same(proto: "epsilon"),
    4: .same(proto: "shift"),
    5: .same(proto: "scale"),
  ]

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_UnaryFunctionLayerParams) -> Bool {
    if self.type != other.type {return false}
    if self.alpha != other.alpha {return false}
    if self.epsilon != other.epsilon {return false}
    if self.shift != other.shift {return false}
    if self.scale != other.scale {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_UnaryFunctionLayerParams.Operation: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SQRT"),
    1: .same(proto: "RSQRT"),
    2: .same(proto: "INVERSE"),
    3: .same(proto: "POWER"),
    4: .same(proto: "EXP"),
    5: .same(proto: "LOG"),
    6: .same(proto: "ABS"),
    7: .same(proto: "THRESHOLD"),
  ]
}

extension CoreML_Specification_UpsampleLayerParams: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "scalingFactor"),
    5: .same(proto: "mode"),
  ]

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_UpsampleLayerParams) -> Bool {
    if self.scalingFactor != other.scalingFactor {return false}
    if self.mode != other.mode {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_UpsampleLayerParams.InterpolationMode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NN"),
    1: .same(proto: "BILINEAR"),
  ]
}

extension CoreML_Specification_BiasLayerParams: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shape"),
    2: .same(proto: "bias"),
  ]

  fileprivate class _StorageClass {
    var _shape: [UInt64] = []
    var _bias: CoreML_Specification_WeightParams? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _shape = source._shape
      _bias = source._bias
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_BiasLayerParams) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._shape != other_storage._shape {return false}
        if _storage._bias != other_storage._bias {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_ScaleLayerParams: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shapeScale"),
    2: .same(proto: "scale"),
    3: .same(proto: "hasBias"),
    4: .same(proto: "shapeBias"),
    5: .same(proto: "bias"),
  ]

  fileprivate class _StorageClass {
    var _shapeScale: [UInt64] = []
    var _scale: CoreML_Specification_WeightParams? = nil
    var _hasBias_p: Bool = false
    var _shapeBias: [UInt64] = []
    var _bias: CoreML_Specification_WeightParams? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _shapeScale = source._shapeScale
      _scale = source._scale
      _hasBias_p = source._hasBias_p
      _shapeBias = source._shapeBias
      _bias = source._bias
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_ScaleLayerParams) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._shapeScale != other_storage._shapeScale {return false}
        if _storage._scale != other_storage._scale {return false}
        if _storage._hasBias_p != other_storage._hasBias_p {return false}
        if _storage._shapeBias != other_storage._shapeBias {return false}
        if _storage._bias != other_storage._bias {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_LoadConstantLayerParams: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shape"),
    2: .same(proto: "data"),
  ]

  fileprivate class _StorageClass {
    var _shape: [UInt64] = []
    var _data: CoreML_Specification_WeightParams? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _shape = source._shape
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_LoadConstantLayerParams) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._shape != other_storage._shape {return false}
        if _storage._data != other_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_L2NormalizeLayerParams: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "epsilon"),
  ]

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_L2NormalizeLayerParams) -> Bool {
    if self.epsilon != other.epsilon {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_FlattenLayerParams: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mode"),
  ]

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_FlattenLayerParams) -> Bool {
    if self.mode != other.mode {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_FlattenLayerParams.FlattenOrder: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CHANNEL_FIRST"),
    1: .same(proto: "CHANNEL_LAST"),
  ]
}

extension CoreML_Specification_ReshapeLayerParams: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "targetShape"),
    2: .same(proto: "mode"),
  ]

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_ReshapeLayerParams) -> Bool {
    if self.targetShape != other.targetShape {return false}
    if self.mode != other.mode {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_ReshapeLayerParams.ReshapeOrder: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CHANNEL_FIRST"),
    1: .same(proto: "CHANNEL_LAST"),
  ]
}

extension CoreML_Specification_PermuteLayerParams: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "axis"),
  ]

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_PermuteLayerParams) -> Bool {
    if self.axis != other.axis {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_ReorganizeDataLayerParams: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mode"),
    2: .same(proto: "blockSize"),
  ]

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_ReorganizeDataLayerParams) -> Bool {
    if self.mode != other.mode {return false}
    if self.blockSize != other.blockSize {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_ReorganizeDataLayerParams.ReorganizationType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SPACE_TO_DEPTH"),
    1: .same(proto: "DEPTH_TO_SPACE"),
  ]
}

extension CoreML_Specification_SliceLayerParams: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "startIndex"),
    2: .same(proto: "endIndex"),
    3: .same(proto: "stride"),
    4: .same(proto: "axis"),
  ]

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_SliceLayerParams) -> Bool {
    if self.startIndex != other.startIndex {return false}
    if self.endIndex != other.endIndex {return false}
    if self.stride != other.stride {return false}
    if self.axis != other.axis {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_SliceLayerParams.SliceAxis: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CHANNEL_AXIS"),
    1: .same(proto: "HEIGHT_AXIS"),
    2: .same(proto: "WIDTH_AXIS"),
  ]
}

extension CoreML_Specification_ReduceLayerParams: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mode"),
    2: .same(proto: "epsilon"),
    3: .same(proto: "axis"),
  ]

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_ReduceLayerParams) -> Bool {
    if self.mode != other.mode {return false}
    if self.epsilon != other.epsilon {return false}
    if self.axis != other.axis {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_ReduceLayerParams.ReduceOperation: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SUM"),
    1: .same(proto: "AVG"),
    2: .same(proto: "PROD"),
    3: .same(proto: "LOGSUM"),
    4: .same(proto: "SUMSQUARE"),
    5: .same(proto: "L1"),
    6: .same(proto: "L2"),
    7: .same(proto: "MAX"),
    8: .same(proto: "MIN"),
    9: .same(proto: "ARGMAX"),
  ]
}

extension CoreML_Specification_ReduceLayerParams.ReduceAxis: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CHW"),
    1: .same(proto: "HW"),
    2: .same(proto: "C"),
    3: .same(proto: "H"),
    4: .same(proto: "W"),
  ]
}

extension CoreML_Specification_CropLayerParams: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cropAmounts"),
    5: .same(proto: "offset"),
  ]

  fileprivate class _StorageClass {
    var _cropAmounts: CoreML_Specification_BorderAmounts? = nil
    var _offset: [UInt64] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _cropAmounts = source._cropAmounts
      _offset = source._offset
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_CropLayerParams) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._cropAmounts != other_storage._cropAmounts {return false}
        if _storage._offset != other_storage._offset {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_AverageLayerParams: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_AverageLayerParams) -> Bool {
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_MaxLayerParams: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_MaxLayerParams) -> Bool {
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_MinLayerParams: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_MinLayerParams) -> Bool {
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_DotProductLayerParams: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cosineSimilarity"),
  ]

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_DotProductLayerParams) -> Bool {
    if self.cosineSimilarity != other.cosineSimilarity {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_MeanVarianceNormalizeLayerParams: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "acrossChannels"),
    2: .same(proto: "normalizeVariance"),
    3: .same(proto: "epsilon"),
  ]

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_MeanVarianceNormalizeLayerParams) -> Bool {
    if self.acrossChannels != other.acrossChannels {return false}
    if self.normalizeVariance != other.normalizeVariance {return false}
    if self.epsilon != other.epsilon {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_SequenceRepeatLayerParams: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nRepetitions"),
  ]

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_SequenceRepeatLayerParams) -> Bool {
    if self.nRepetitions != other.nRepetitions {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_SimpleRecurrentLayerParams: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "inputVectorSize"),
    2: .same(proto: "outputVectorSize"),
    10: .same(proto: "activation"),
    15: .same(proto: "sequenceOutput"),
    20: .same(proto: "hasBiasVector"),
    30: .same(proto: "weightMatrix"),
    31: .same(proto: "recursionMatrix"),
    32: .same(proto: "biasVector"),
    100: .same(proto: "reverseInput"),
  ]

  fileprivate class _StorageClass {
    var _inputVectorSize: UInt64 = 0
    var _outputVectorSize: UInt64 = 0
    var _activation: CoreML_Specification_ActivationParams? = nil
    var _sequenceOutput: Bool = false
    var _hasBiasVector_p: Bool = false
    var _weightMatrix: CoreML_Specification_WeightParams? = nil
    var _recursionMatrix: CoreML_Specification_WeightParams? = nil
    var _biasVector: CoreML_Specification_WeightParams? = nil
    var _reverseInput: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _inputVectorSize = source._inputVectorSize
      _outputVectorSize = source._outputVectorSize
      _activation = source._activation
      _sequenceOutput = source._sequenceOutput
      _hasBiasVector_p = source._hasBiasVector_p
      _weightMatrix = source._weightMatrix
      _recursionMatrix = source._recursionMatrix
      _biasVector = source._biasVector
      _reverseInput = source._reverseInput
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_SimpleRecurrentLayerParams) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._inputVectorSize != other_storage._inputVectorSize {return false}
        if _storage._outputVectorSize != other_storage._outputVectorSize {return false}
        if _storage._activation != other_storage._activation {return false}
        if _storage._sequenceOutput != other_storage._sequenceOutput {return false}
        if _storage._hasBiasVector_p != other_storage._hasBiasVector_p {return false}
        if _storage._weightMatrix != other_storage._weightMatrix {return false}
        if _storage._recursionMatrix != other_storage._recursionMatrix {return false}
        if _storage._biasVector != other_storage._biasVector {return false}
        if _storage._reverseInput != other_storage._reverseInput {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_GRULayerParams: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "inputVectorSize"),
    2: .same(proto: "outputVectorSize"),
    10: .same(proto: "activations"),
    15: .same(proto: "sequenceOutput"),
    20: .same(proto: "hasBiasVectors"),
    30: .same(proto: "updateGateWeightMatrix"),
    31: .same(proto: "resetGateWeightMatrix"),
    32: .same(proto: "outputGateWeightMatrix"),
    50: .same(proto: "updateGateRecursionMatrix"),
    51: .same(proto: "resetGateRecursionMatrix"),
    52: .same(proto: "outputGateRecursionMatrix"),
    70: .same(proto: "updateGateBiasVector"),
    71: .same(proto: "resetGateBiasVector"),
    72: .same(proto: "outputGateBiasVector"),
    100: .same(proto: "reverseInput"),
  ]

  fileprivate class _StorageClass {
    var _inputVectorSize: UInt64 = 0
    var _outputVectorSize: UInt64 = 0
    var _activations: [CoreML_Specification_ActivationParams] = []
    var _sequenceOutput: Bool = false
    var _hasBiasVectors_p: Bool = false
    var _updateGateWeightMatrix: CoreML_Specification_WeightParams? = nil
    var _resetGateWeightMatrix: CoreML_Specification_WeightParams? = nil
    var _outputGateWeightMatrix: CoreML_Specification_WeightParams? = nil
    var _updateGateRecursionMatrix: CoreML_Specification_WeightParams? = nil
    var _resetGateRecursionMatrix: CoreML_Specification_WeightParams? = nil
    var _outputGateRecursionMatrix: CoreML_Specification_WeightParams? = nil
    var _updateGateBiasVector: CoreML_Specification_WeightParams? = nil
    var _resetGateBiasVector: CoreML_Specification_WeightParams? = nil
    var _outputGateBiasVector: CoreML_Specification_WeightParams? = nil
    var _reverseInput: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _inputVectorSize = source._inputVectorSize
      _outputVectorSize = source._outputVectorSize
      _activations = source._activations
      _sequenceOutput = source._sequenceOutput
      _hasBiasVectors_p = source._hasBiasVectors_p
      _updateGateWeightMatrix = source._updateGateWeightMatrix
      _resetGateWeightMatrix = source._resetGateWeightMatrix
      _outputGateWeightMatrix = source._outputGateWeightMatrix
      _updateGateRecursionMatrix = source._updateGateRecursionMatrix
      _resetGateRecursionMatrix = source._resetGateRecursionMatrix
      _outputGateRecursionMatrix = source._outputGateRecursionMatrix
      _updateGateBiasVector = source._updateGateBiasVector
      _resetGateBiasVector = source._resetGateBiasVector
      _outputGateBiasVector = source._outputGateBiasVector
      _reverseInput = source._reverseInput
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_GRULayerParams) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._inputVectorSize != other_storage._inputVectorSize {return false}
        if _storage._outputVectorSize != other_storage._outputVectorSize {return false}
        if _storage._activations != other_storage._activations {return false}
        if _storage._sequenceOutput != other_storage._sequenceOutput {return false}
        if _storage._hasBiasVectors_p != other_storage._hasBiasVectors_p {return false}
        if _storage._updateGateWeightMatrix != other_storage._updateGateWeightMatrix {return false}
        if _storage._resetGateWeightMatrix != other_storage._resetGateWeightMatrix {return false}
        if _storage._outputGateWeightMatrix != other_storage._outputGateWeightMatrix {return false}
        if _storage._updateGateRecursionMatrix != other_storage._updateGateRecursionMatrix {return false}
        if _storage._resetGateRecursionMatrix != other_storage._resetGateRecursionMatrix {return false}
        if _storage._outputGateRecursionMatrix != other_storage._outputGateRecursionMatrix {return false}
        if _storage._updateGateBiasVector != other_storage._updateGateBiasVector {return false}
        if _storage._resetGateBiasVector != other_storage._resetGateBiasVector {return false}
        if _storage._outputGateBiasVector != other_storage._outputGateBiasVector {return false}
        if _storage._reverseInput != other_storage._reverseInput {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_LSTMParams: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    10: .same(proto: "sequenceOutput"),
    20: .same(proto: "hasBiasVectors"),
    30: .same(proto: "forgetBias"),
    40: .same(proto: "hasPeepholeVectors"),
    50: .same(proto: "coupledInputAndForgetGate"),
    60: .same(proto: "cellClipThreshold"),
  ]

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_LSTMParams) -> Bool {
    if self.sequenceOutput != other.sequenceOutput {return false}
    if self.hasBiasVectors_p != other.hasBiasVectors_p {return false}
    if self.forgetBias != other.forgetBias {return false}
    if self.hasPeepholeVectors_p != other.hasPeepholeVectors_p {return false}
    if self.coupledInputAndForgetGate != other.coupledInputAndForgetGate {return false}
    if self.cellClipThreshold != other.cellClipThreshold {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_LSTMWeightParams: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "inputGateWeightMatrix"),
    2: .same(proto: "forgetGateWeightMatrix"),
    3: .same(proto: "blockInputWeightMatrix"),
    4: .same(proto: "outputGateWeightMatrix"),
    20: .same(proto: "inputGateRecursionMatrix"),
    21: .same(proto: "forgetGateRecursionMatrix"),
    22: .same(proto: "blockInputRecursionMatrix"),
    23: .same(proto: "outputGateRecursionMatrix"),
    40: .same(proto: "inputGateBiasVector"),
    41: .same(proto: "forgetGateBiasVector"),
    42: .same(proto: "blockInputBiasVector"),
    43: .same(proto: "outputGateBiasVector"),
    60: .same(proto: "inputGatePeepholeVector"),
    61: .same(proto: "forgetGatePeepholeVector"),
    62: .same(proto: "outputGatePeepholeVector"),
  ]

  fileprivate class _StorageClass {
    var _inputGateWeightMatrix: CoreML_Specification_WeightParams? = nil
    var _forgetGateWeightMatrix: CoreML_Specification_WeightParams? = nil
    var _blockInputWeightMatrix: CoreML_Specification_WeightParams? = nil
    var _outputGateWeightMatrix: CoreML_Specification_WeightParams? = nil
    var _inputGateRecursionMatrix: CoreML_Specification_WeightParams? = nil
    var _forgetGateRecursionMatrix: CoreML_Specification_WeightParams? = nil
    var _blockInputRecursionMatrix: CoreML_Specification_WeightParams? = nil
    var _outputGateRecursionMatrix: CoreML_Specification_WeightParams? = nil
    var _inputGateBiasVector: CoreML_Specification_WeightParams? = nil
    var _forgetGateBiasVector: CoreML_Specification_WeightParams? = nil
    var _blockInputBiasVector: CoreML_Specification_WeightParams? = nil
    var _outputGateBiasVector: CoreML_Specification_WeightParams? = nil
    var _inputGatePeepholeVector: CoreML_Specification_WeightParams? = nil
    var _forgetGatePeepholeVector: CoreML_Specification_WeightParams? = nil
    var _outputGatePeepholeVector: CoreML_Specification_WeightParams? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _inputGateWeightMatrix = source._inputGateWeightMatrix
      _forgetGateWeightMatrix = source._forgetGateWeightMatrix
      _blockInputWeightMatrix = source._blockInputWeightMatrix
      _outputGateWeightMatrix = source._outputGateWeightMatrix
      _inputGateRecursionMatrix = source._inputGateRecursionMatrix
      _forgetGateRecursionMatrix = source._forgetGateRecursionMatrix
      _blockInputRecursionMatrix = source._blockInputRecursionMatrix
      _outputGateRecursionMatrix = source._outputGateRecursionMatrix
      _inputGateBiasVector = source._inputGateBiasVector
      _forgetGateBiasVector = source._forgetGateBiasVector
      _blockInputBiasVector = source._blockInputBiasVector
      _outputGateBiasVector = source._outputGateBiasVector
      _inputGatePeepholeVector = source._inputGatePeepholeVector
      _forgetGatePeepholeVector = source._forgetGatePeepholeVector
      _outputGatePeepholeVector = source._outputGatePeepholeVector
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_LSTMWeightParams) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._inputGateWeightMatrix != other_storage._inputGateWeightMatrix {return false}
        if _storage._forgetGateWeightMatrix != other_storage._forgetGateWeightMatrix {return false}
        if _storage._blockInputWeightMatrix != other_storage._blockInputWeightMatrix {return false}
        if _storage._outputGateWeightMatrix != other_storage._outputGateWeightMatrix {return false}
        if _storage._inputGateRecursionMatrix != other_storage._inputGateRecursionMatrix {return false}
        if _storage._forgetGateRecursionMatrix != other_storage._forgetGateRecursionMatrix {return false}
        if _storage._blockInputRecursionMatrix != other_storage._blockInputRecursionMatrix {return false}
        if _storage._outputGateRecursionMatrix != other_storage._outputGateRecursionMatrix {return false}
        if _storage._inputGateBiasVector != other_storage._inputGateBiasVector {return false}
        if _storage._forgetGateBiasVector != other_storage._forgetGateBiasVector {return false}
        if _storage._blockInputBiasVector != other_storage._blockInputBiasVector {return false}
        if _storage._outputGateBiasVector != other_storage._outputGateBiasVector {return false}
        if _storage._inputGatePeepholeVector != other_storage._inputGatePeepholeVector {return false}
        if _storage._forgetGatePeepholeVector != other_storage._forgetGatePeepholeVector {return false}
        if _storage._outputGatePeepholeVector != other_storage._outputGatePeepholeVector {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_UniDirectionalLSTMLayerParams: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "inputVectorSize"),
    2: .same(proto: "outputVectorSize"),
    10: .same(proto: "activations"),
    15: .same(proto: "params"),
    20: .same(proto: "weightParams"),
    100: .same(proto: "reverseInput"),
  ]

  fileprivate class _StorageClass {
    var _inputVectorSize: UInt64 = 0
    var _outputVectorSize: UInt64 = 0
    var _activations: [CoreML_Specification_ActivationParams] = []
    var _params: CoreML_Specification_LSTMParams? = nil
    var _weightParams: CoreML_Specification_LSTMWeightParams? = nil
    var _reverseInput: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _inputVectorSize = source._inputVectorSize
      _outputVectorSize = source._outputVectorSize
      _activations = source._activations
      _params = source._params
      _weightParams = source._weightParams
      _reverseInput = source._reverseInput
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_UniDirectionalLSTMLayerParams) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._inputVectorSize != other_storage._inputVectorSize {return false}
        if _storage._outputVectorSize != other_storage._outputVectorSize {return false}
        if _storage._activations != other_storage._activations {return false}
        if _storage._params != other_storage._params {return false}
        if _storage._weightParams != other_storage._weightParams {return false}
        if _storage._reverseInput != other_storage._reverseInput {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_BiDirectionalLSTMLayerParams: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "inputVectorSize"),
    2: .same(proto: "outputVectorSize"),
    10: .same(proto: "activationsForwardLSTM"),
    11: .same(proto: "activationsBackwardLSTM"),
    15: .same(proto: "params"),
    20: .same(proto: "weightParams"),
  ]

  fileprivate class _StorageClass {
    var _inputVectorSize: UInt64 = 0
    var _outputVectorSize: UInt64 = 0
    var _activationsForwardLstm: [CoreML_Specification_ActivationParams] = []
    var _activationsBackwardLstm: [CoreML_Specification_ActivationParams] = []
    var _params: CoreML_Specification_LSTMParams? = nil
    var _weightParams: [CoreML_Specification_LSTMWeightParams] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _inputVectorSize = source._inputVectorSize
      _outputVectorSize = source._outputVectorSize
      _activationsForwardLstm = source._activationsForwardLstm
      _activationsBackwardLstm = source._activationsBackwardLstm
      _params = source._params
      _weightParams = source._weightParams
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_BiDirectionalLSTMLayerParams) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._inputVectorSize != other_storage._inputVectorSize {return false}
        if _storage._outputVectorSize != other_storage._outputVectorSize {return false}
        if _storage._activationsForwardLstm != other_storage._activationsForwardLstm {return false}
        if _storage._activationsBackwardLstm != other_storage._activationsBackwardLstm {return false}
        if _storage._params != other_storage._params {return false}
        if _storage._weightParams != other_storage._weightParams {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_NeuralNetworkClassifier: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "layers"),
    2: .same(proto: "preprocessing"),
    100: .same(proto: "stringClassLabels"),
    101: .same(proto: "int64ClassLabels"),
    200: .same(proto: "labelProbabilityLayerName"),
  ]

  fileprivate class _StorageClass {
    var _layers: [CoreML_Specification_NeuralNetworkLayer] = []
    var _preprocessing: [CoreML_Specification_NeuralNetworkPreprocessing] = []
    var _classLabels: CoreML_Specification_NeuralNetworkClassifier.OneOf_ClassLabels?
    var _labelProbabilityLayerName: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _layers = source._layers
      _preprocessing = source._preprocessing
      _classLabels = source._classLabels
      _labelProbabilityLayerName = source._labelProbabilityLayerName
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_NeuralNetworkClassifier) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._layers != other_storage._layers {return false}
        if _storage._preprocessing != other_storage._preprocessing {return false}
        if _storage._classLabels != other_storage._classLabels {return false}
        if _storage._labelProbabilityLayerName != other_storage._labelProbabilityLayerName {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_NeuralNetworkRegressor: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "layers"),
    2: .same(proto: "preprocessing"),
  ]

  public func _protobuf_generated_isEqualTo(other: CoreML_Specification_NeuralNetworkRegressor) -> Bool {
    if self.layers != other.layers {return false}
    if self.preprocessing != other.preprocessing {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}
